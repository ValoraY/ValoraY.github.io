<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"valoray.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《动手学深度学习2.0》学习笔记（三） 《动手学深度学习2.0》电子书的链接地址为https:&#x2F;&#x2F;zh.d2l.ai&#x2F;index.html 本文记录了我在学习本书8-10章节（包括循环神经网络、现代循环神经网络、注意力机制）过程中的理解和收获。">
<meta property="og:type" content="article">
<meta property="og:title" content="《动手学深度学习2.0》学习笔记（三）">
<meta property="og:url" content="https://valoray.github.io/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/index.html">
<meta property="og:site_name" content="DeepRookie">
<meta property="og:description" content="《动手学深度学习2.0》学习笔记（三） 《动手学深度学习2.0》电子书的链接地址为https:&#x2F;&#x2F;zh.d2l.ai&#x2F;index.html 本文记录了我在学习本书8-10章节（包括循环神经网络、现代循环神经网络、注意力机制）过程中的理解和收获。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-16T08:26:50.000Z">
<meta property="article:modified_time" content="2024-01-16T08:56:16.898Z">
<meta property="article:author" content="deeprookie">
<meta property="article:tag" content="动手学深度学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://valoray.github.io/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://valoray.github.io/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","path":"2024/01/16/《动手学深度学习2-0》学习笔记（三）/","title":"《动手学深度学习2.0》学习笔记（三）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《动手学深度学习2.0》学习笔记（三） | DeepRookie</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">DeepRookie</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">想到，就去做，无非一朝还是一生</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89"><span class="nav-number">1.</span> <span class="nav-text">《动手学深度学习2.0》学习笔记（三）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.1.</span> <span class="nav-text">循环神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7"><span class="nav-number">1.1.2.</span> <span class="nav-text">处理序列数据的统计工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">自回归模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">自回归模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%8F%98%E9%87%8F%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">隐变量自回归模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">马尔可夫模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">文本预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">1.1.4.</span> <span class="nav-text">构建数据集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">随机采样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%88%86%E5%8C%BA"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">顺序分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-1"><span class="nav-number">1.1.5.</span> <span class="nav-text">循环神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E9%9A%90%E7%8A%B6%E6%80%81%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">有隐状态的循环神经网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BA%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">基于循环神经网络的字符级语言模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%B0%E6%83%91%E5%BA%A6perplexity"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">困惑度（Perplexity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">从零实现循环神经网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%97%B6%E9%97%B4%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="nav-number">1.1.5.6.</span> <span class="nav-text">通过时间反向传播</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.</span> <span class="nav-text">现代循环神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83gru"><span class="nav-number">1.2.1.</span> <span class="nav-text">门控循环单元(GRU)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8E%A7%E9%9A%90%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">门控隐状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E9%97%A8%E5%92%8C%E6%9B%B4%E6%96%B0%E9%97%A8"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">重置门和更新门</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%99%E9%80%89%E9%9A%90%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">候选隐状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">隐状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9Clstm"><span class="nav-number">1.2.2.</span> <span class="nav-text">长短期记忆网络(LSTM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8E%A7%E8%AE%B0%E5%BF%86%E5%85%83"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">门控记忆元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E9%97%A8%E9%81%97%E5%BF%98%E9%97%A8%E5%92%8C%E8%BE%93%E5%87%BA%E9%97%A8"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">输入门、遗忘门和输出门</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%99%E9%80%89%E8%AE%B0%E5%BF%86%E5%85%83"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">候选记忆元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%85%83"><span class="nav-number">1.2.2.1.3.</span> <span class="nav-text">记忆元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E7%8A%B6%E6%80%81-1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">隐状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">深度循环神经网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.4.</span> <span class="nav-text">双向循环神经网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8-%E8%A7%A3%E7%A0%81%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.5.</span> <span class="nav-text">编码器-解码器架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%88%B0%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0seq2seg"><span class="nav-number">1.2.6.</span> <span class="nav-text">序列到序列学习(seq2seg)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">注意力机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%8F%90%E7%A4%BA"><span class="nav-number">1.3.1.</span> <span class="nav-text">注意力提示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%BB%84%E4%BB%B6two-component%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">双组件（two-component）框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%94%AE%E5%92%8C%E5%80%BC"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">查询、键和值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">可视化注意力</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%B1%87%E8%81%9A"><span class="nav-number">1.3.2.</span> <span class="nav-text">注意力汇聚</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%8F%82%E6%95%B0%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%B1%87%E8%81%9A"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">非参数注意力汇聚</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#nadaraya-watson%E6%A0%B8%E5%9B%9E%E5%BD%92"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">Nadaraya-Watson核回归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%B1%87%E8%81%9Aattention-pooling%E5%85%AC%E5%BC%8F"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">通用的注意力汇聚（attention
pooling）公式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nadaraya-watson%E9%AB%98%E6%96%AF%E6%A0%B8%E5%9B%9E%E5%BD%92"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">Nadaraya-Watson高斯核回归</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%B1%87%E8%81%9A"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">带参数的注意力汇聚</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">定义模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E9%9D%9E%E5%8F%82%E6%95%B0%E5%92%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%B1%87%E8%81%9A"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">对比非参数和带参数的注意力汇聚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E8%AF%84%E5%88%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">注意力评分函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-1"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">数学描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AF%84%E5%88%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">常用评分函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E6%80%A7%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">加性注意力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%A9%E6%94%BE%E7%82%B9%E7%A7%AF%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">缩放点积注意力</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bahdanau-%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.4.</span> <span class="nav-text">Bahdanau 注意力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-2"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bahdanau-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Bahdanau 注意力模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E6%84%8F%E5%8A%9B%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">定义注意力解码器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.5.</span> <span class="nav-text">多头注意力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-3"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">数学描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.6.</span> <span class="nav-text">自注意力和位置编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-4"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">自注意力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">比较卷积神经网络、循环神经网络和自注意力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">位置编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-5"><span class="nav-number">1.3.6.4.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%AD%A3%E5%BC%A6%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%99%E5%BC%A6%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%BA%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.6.4.2.</span> <span class="nav-text">基于正弦函数和余弦函数的固定位置编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transformer"><span class="nav-number">1.3.7.</span> <span class="nav-text">Transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E5%89%8D%E9%A6%88%E7%BD%91%E7%BB%9C"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">位置前馈网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%B1%82%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">残差连接和层规范化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.7.3.1.</span> <span class="nav-text">残差连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%82%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">1.3.7.3.2.</span> <span class="nav-text">层规范化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">编码器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.3.7.5.</span> <span class="nav-text">解码器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.3.7.6.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="deeprookie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">deeprookie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ValoraY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ValoraY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1432843916@qq.com" title="E-Mail → mailto:1432843916@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/m0_51619560/category_12535222.html" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51619560&#x2F;category_12535222.html" rel="noopener me" target="_blank">CSDN</a>
      </span>
  </div>

    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/2024/01/17/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（四）" target="_blank">《动手学深度学习2.0》学习笔记（四）</a>
          </li>
        
          <li>
            <a href="/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（三）" target="_blank">《动手学深度学习2.0》学习笔记（三）</a>
          </li>
        
          <li>
            <a href="/2024/01/12/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（二）" target="_blank">《动手学深度学习2.0》学习笔记（二）</a>
          </li>
        
          <li>
            <a href="/2024/01/11/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（一）" target="_blank">《动手学深度学习2.0》学习笔记（一）</a>
          </li>
        
          <li>
            <a href="/2024/01/04/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Coze%E6%95%99%E7%A8%8B%EF%BC%88GPT4%EF%BC%89/" title="字节跳动Coze教程（GPT4）" target="_blank">字节跳动Coze教程（GPT4）</a>
          </li>
        
      </ul>
    </div>


        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://valoray.github.io/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="deeprookie">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DeepRookie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《动手学深度学习2.0》学习笔记（三） | DeepRookie">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《动手学深度学习2.0》学习笔记（三）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-01-16 16:26:50 / 修改时间：16:56:16" itemprop="dateCreated datePublished" datetime="2024-01-16T16:26:50+08:00">2024-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1
id="动手学深度学习2.0学习笔记三">《动手学深度学习2.0》学习笔记（三）</h1>
<p>《动手学深度学习2.0》电子书的链接地址为https://zh.d2l.ai/index.html</p>
<p>本文记录了我在学习本书8-10章节（包括循环神经网络、现代循环神经网络、注意力机制）过程中的理解和收获。</p>
<span id="more"></span>
<h2 id="循环神经网络">循环神经网络</h2>
<h3 id="引言">引言</h3>
<p>data：表格数据、图像数据、序列数据。</p>
<ul>
<li>对于表格数据和图像数据，我们默认所有样本都是独立同分布的</li>
<li>表格数据：通常利用机器学习、多层感知机处理</li>
<li>图像数据：通常利用卷积神经网络（可以有效利用空间信息）</li>
<li><strong>序列数据：循环神经网络（recurrent neural
network，RNN）</strong></li>
</ul>
<h3 id="处理序列数据的统计工具">处理序列数据的统计工具</h3>
<p>在处理序列数据时，我们面对的问题是——如何有效估计<span
class="math inline">\(P(x_t\mid
x_{t-1},\ldots,x_1)\)</span>，这需要专门的统计工具，两种较流行的选择是自回归模型和隐变量自回归模型。</p>
<h4 id="自回归模型">自回归模型</h4>
<h5 id="自回归模型-1">自回归模型</h5>
<p>第一种策略，假设在现实情况下相当长的序列<span
class="math inline">\(x_{t-1},\ldots,x_1\)</span>可能是不必要的，因此我们只需要满足某个长度为<span
class="math inline">\(\tau\)</span>的时间跨度，即使用观测序列<span
class="math inline">\(x_{t-1},\ldots,x_{t-\tau}\)</span>。当下获得的最直接的好处就是参数的数量总是不变的，至少在<span
class="math inline">\(t&gt;\tau\)</span>时如此，这就使我们能够训练一个上面提及的深度网络。这种模型被称为<strong>自回归模型
(autoregressive models)</strong> , 因为它们是对自己执行回归。</p>
<h5 id="隐变量自回归模型">隐变量自回归模型</h5>
<p>第二种策略，如图所示，是保留一些对过去观测的总结<span
class="math inline">\(h_t\)</span>, 并且同时更新预测<span
class="math inline">\(\hat{x}_{t}\)</span>和总结<span
class="math inline">\(h_{t}\)</span>。由于<span
class="math inline">\(h_t\)</span>从未被观测到，这类模型也被称为<strong>隐变量自回归模型
(latent autoregressive models)</strong> 。 <span class="math display">\[
\hat{x}_t=P(x_t\mid h_t)
\]</span></p>
<p><span class="math display">\[
h_t=g(h_{t-1},x_{t-1})
\]</span></p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161645545.png"
alt="隐变量自回归模型" />
<figcaption aria-hidden="true">隐变量自回归模型</figcaption>
</figure>
<p>因此，整个序列的估计值都将通过以下的方式获得：</p>
<p><span class="math display">\[
P(x_1,\ldots,x_T)=\prod_{t=1}^TP(x_t\mid x_{t-1},\ldots,x_1).
\]</span> 注意，如果我们处理的是离散的对象(如单词),
而不是连续的数字，则上述的考虑仍然有效。唯一的差别是，对于离散的对象，我们需要使用分类器而不是回归模型来估计<span
class="math inline">\(P(x_t\mid x_{t-1},\ldots,x_1)\)</span>。</p>
<h4 id="马尔可夫模型">马尔可夫模型</h4>
<p>当序列满足一阶马尔可夫模型（first-order Markov model）时，<span
class="math inline">\(P(x)\)</span>由下式给出： <span
class="math display">\[
P(x_1,\ldots,x_T)=\prod_{t=1}^TP(x_t\mid x_{t-1}){\text{当}}P(x_1\mid
x_0)=P(x_1).
\]</span> 当假设<span
class="math inline">\(x_t\)</span>仅是离散值时，可以推导出以下结论：
<span class="math display">\[
P(x_{t+1}|x_t,x_{t-1})=P(x_{t+1}|x_t)
\]</span> 含义是，在满足了前一个状态 <span
class="math inline">\(x_t\)</span> 的条件下，当前状态 <span
class="math inline">\(x_{t+1}\)</span> 的概率分布与更早的历史状态 <span
class="math inline">\(x_{t-1}\)</span>
无关。这个表达式揭示了马尔可夫性质的一种特殊情况，即当前状态的概率分布仅仅依赖于前一个状态。换句话说，给定了前一个状态
<span class="math inline">\(x_t\)</span> 后，更早的历史状态 <span
class="math inline">\(x_{t-1}\)</span> 对于预测当前状态 <span
class="math inline">\(x_{t+1}\)</span> 的概率分布没有直接的影响。</p>
<h3 id="文本预处理">文本预处理</h3>
<p>文本的常见预处理步骤包括：</p>
<ol type="1">
<li>读取数据集：将文本作为字符串加载到内存中。</li>
<li>词元化：将字符串拆分为词元（如单词和字符）。
<ul>
<li><em>语料</em>（corpus）：将训练集中的所有文档合并在一起，对它们的唯一词元进行统计，
得到的统计结果称之为<em>语料</em>（corpus）</li>
<li>未知词元：“<unk>”，用于映射语料库中不存在或已删除的任何词元</li>
<li>其他保留词元：填充词元（“<pad>”）； 序列开始词元（“<bos>”）；
序列结束词元（“<eos>”）</li>
</ul></li>
<li>建立词表：建立一个词表，将拆分的词元映射到数字索引。</li>
<li>将文本转换为数字索引序列，方便模型操作。</li>
</ol>
<h3 id="构建数据集">构建数据集</h3>
<p>对于语言建模任务，模型的目标就是预测序列中每一个位置的下一个词元。因此对于每个小批量，我们都需要产生一个源序列（X）以及相应的目标序列（Y），目标序列是源序列向右移动了一个位置的序列。下面描述两种构造数据集的策略，分别是<em>随机采样</em>（random
sampling）和 <em>顺序分区</em>（sequential partitioning）</p>
<h4 id="随机采样">随机采样</h4>
<ol type="1">
<li>选择任意偏移量来指示初始位置</li>
<li>在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_random</span>(<span class="params">corpus, batch_size, num_steps</span>): </span><br><span class="line">    <span class="comment"># 使用随机抽样生成一个小批量子序列</span></span><br><span class="line">    <span class="comment"># 首先从原始序列中随机选择一个开始点</span></span><br><span class="line">    corpus = corpus[random.randint(<span class="number">0</span>, num_steps - <span class="number">1</span>):]</span><br><span class="line">    <span class="comment"># 计算可以生成的子序列数量。减1的目的是确保有足够的字符留给标签序列</span></span><br><span class="line">    num_subseqs = (<span class="built_in">len</span>(corpus) - <span class="number">1</span>) // num_steps    <span class="comment">#子序列样本数量</span></span><br><span class="line">    <span class="comment"># 生成每个子序列的起始索引</span></span><br><span class="line">    initial_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, num_subseqs * num_steps, num_steps))</span><br><span class="line">    <span class="comment"># 随机排列子序列的起始索引，打乱顺序，</span></span><br><span class="line">    <span class="comment"># 导致每个小批量中的子序列在原始序列上并不一定是相邻的</span></span><br><span class="line">    random.shuffle(initial_indices)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">pos</span>):</span><br><span class="line">        <span class="comment"># 返回从pos位置开始的长度为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus[pos: pos + num_steps]</span><br><span class="line"></span><br><span class="line">    num_batches = num_subseqs // batch_size    <span class="comment">#计算小批量的数量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size * num_batches, batch_size):</span><br><span class="line">        <span class="comment"># 对所有小批量进行遍历</span></span><br><span class="line">        initial_indices_per_batch = initial_indices[i: i + batch_size]    <span class="comment">#每个小批量中的子序列的起始索引</span></span><br><span class="line">        <span class="comment"># 定义输入X，是根据initial_indices_per_batch中的索引得到的源序列</span></span><br><span class="line">        X = [data(j) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        <span class="comment"># 定义标签Y，是在源序列基础上向后偏移一个单位得到的序列</span></span><br><span class="line">        Y = [data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        <span class="comment"># 每次迭代返回一个小批量的输入X和标签Y</span></span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X), torch.tensor(Y)</span><br></pre></td></tr></table></figure>
<h4 id="顺序分区">顺序分区</h4>
<ol type="1">
<li>选择任意偏移量来指示初始位置</li>
<li>在获得第一个子序列后，后面的子序列都按照顺序来获取</li>
</ol>
<p>这种方法更加能保证上下文的完整性，从而获得更好的训练效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_sequential</span>(<span class="params">corpus, batch_size, num_steps</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="comment"># 使用顺序分区生成一个小批量子序列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从随机偏移量开始划分序列</span></span><br><span class="line">    offset = random.randint(<span class="number">0</span>, num_steps)   </span><br><span class="line">    <span class="comment"># 计算总的有效 token 数量，这样的话，计算出的 num_tokens 能被 batch_size 整除</span></span><br><span class="line">    num_tokens = ((<span class="built_in">len</span>(corpus) - offset - <span class="number">1</span>) // batch_size) * batch_size</span><br><span class="line">    <span class="comment"># 剔除不需要的 tokens，然后将 corpus 转变为 tensor</span></span><br><span class="line">    Xs = torch.tensor(corpus[offset: offset + num_tokens])</span><br><span class="line">    <span class="comment"># 类似地，对应的标签也需要进行相同的处理。标签序列是源序列向后移动了一个位置的序列</span></span><br><span class="line">    Ys = torch.tensor(corpus[offset + <span class="number">1</span>: offset + <span class="number">1</span> + num_tokens])</span><br><span class="line">    <span class="comment"># 重塑数据的形状，使得它们可以被划分成一个个小批量</span></span><br><span class="line">    Xs, Ys = Xs.reshape(batch_size, -<span class="number">1</span>), Ys.reshape(batch_size, -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 计算最后能生成多少个小批量</span></span><br><span class="line">    num_batches = Xs.shape[<span class="number">1</span>] // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_steps * num_batches, num_steps):</span><br><span class="line">        <span class="comment"># 每次选取一个长度为 num_steps 的子序列作为一个小批量</span></span><br><span class="line">        X = Xs[:, i: i + num_steps]</span><br><span class="line">        Y = Ys[:, i: i + num_steps]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回一个小批量的数据和标签</span></span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure>
<h3 id="循环神经网络-1">循环神经网络</h3>
<h4 id="引入">引入</h4>
<ol type="1">
<li>使用隐变量模型来估计<span class="math inline">\(P(x_t\mid
x_{t-1},\ldots,x_1)\)</span>：</li>
</ol>
<p><span class="math display">\[
P(x_t\mid x_{t-1},\ldots,x_1)\approx P(x_t\mid h_{t-1}),
\]</span></p>
<p>其中<span class="math inline">\(h_{t-1}\)</span>是隐状态(hidden
state), 也称为隐藏变量 (hidden variable), 它存储了到时间步<span
class="math inline">\(t-1\)</span>的序列信息。通常，我们可以基于当前输入<span
class="math inline">\(x_t\)</span>和先前隐状态<span
class="math inline">\(h_{t-1}\)</span> 来计算时间步<span
class="math inline">\(t\)</span>处的任何时间的隐状态： <span
class="math display">\[
h_t=f(x_t,h_{t-1}).
\]</span></p>
<ol start="2" type="1">
<li><p><strong>隐藏层</strong>和<strong>隐状态</strong>指的是两个截然不同的概念。隐藏层是在从输入到输出的路径上（以观测角度来理解）的隐藏的层，
而隐状态则是在给定步骤所做的任何事情（以技术角度来定义）的<em>输入</em>，
并且这些状态只能通过先前时间步的数据来计算。</p></li>
<li><p><em>循环神经网络</em>（recurrent neural networks，RNNs）
是具有<strong>隐状态</strong>的神经网络。</p></li>
</ol>
<h4 id="有隐状态的循环神经网络">有隐状态的循环神经网络</h4>
<p>假设在时间步<span class="math inline">\(t\)</span>有小批量输入<span
class="math inline">\(\mathbf{X}_t\in\mathbb{R}^{n\times
d}\)</span>。换言之，对于<span
class="math inline">\(n\)</span>个序列样本的小批量，<span
class="math inline">\(\mathbf{X}_t\)</span>
的每一行对应于来自该序列的时间步<span
class="math inline">\(t\)</span>处的一个样本。接下来，用<span
class="math inline">\(\mathbf{H}_t\in\mathbb{R}^{n\times h}\)</span>
表示时间步<span
class="math inline">\(t\)</span>的隐藏变量。与多层感知机不同的是，我们在这里保存了前一个时间步的隐藏变量<span
class="math inline">\(\mathbf{H}_{t-1}\)</span>,并引入了一个新的权重参数<span
class="math inline">\(\mathbf{W}_{hh}\in\mathbb{R}^{h\times h}\)</span>,
来描述如何在当前时间步中使用前一个时间步的隐藏变量。具体地说，当前时间步隐藏变量由当前时间步的输入与前一个时间步的隐藏变量一起计算得出：</p>
<p><span class="math display">\[
\mathbf{H}_t=\phi(\mathbf{X}_t\mathbf{W}_{xh}+\mathbf{H}_{t-1}\mathbf{W}_{hh}+\mathbf{b}_h).
\]</span> 相比于多层感知机的计算，上式添加了一项 <span
class="math inline">\(\mathbf{H}_{t-1}\mathbf{W}_{hh}\)</span>,
从而实例化了 <span
class="math inline">\(h_t=f(x_t,h_{t-1})\)</span>。从相邻时间步的隐藏变量<span
class="math inline">\(\mathbf{H}_t\)</span>和 <span
class="math inline">\(\mathbf{H}_{t-1}\)</span>之间的关系可知，<strong>这些变量捕获并保留了序列直到其当前时间步的历史信息，就如当前时间步下神经网络的状态或记忆，因此这样的隐藏变量被称为隐状态(hidden
state)</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161645795.png"
alt="具有隐状态的循环神经网络" />
<figcaption aria-hidden="true">具有隐状态的循环神经网络</figcaption>
</figure>
<h4
id="基于循环神经网络的字符级语言模型">基于循环神经网络的字符级语言模型</h4>
<p>下图演示了如何通过基于字符级语言建模的循环神经网络，使用当前的和先前的字符预测下一个字符。设小批量大小为1，批量中的文本序列为“machine”。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161646218.png"
alt="基于循环神经网络的字符级语言模型：输入序列和标签序列分别为“machin”和“achine”" />
<figcaption
aria-hidden="true">基于循环神经网络的字符级语言模型：输入序列和标签序列分别为“machin”和“achine”</figcaption>
</figure>
<p>在训练过程中，我们对每个时间步的输出层的输出进行softmax操作，然后利用交叉熵损失计算模型输出和标签之间的误差。由于隐藏层中隐状态的循环计算，上图中的第3个时间步的输出<span
class="math inline">\(\mathbf{O}_{3}\)</span>
由文本序列"m"a"和"c"确定。由于训练数据中这个文本序列的下一个字符是"h",
因此第3个时间步的损失将取决于下一个字符的概率分布，而下一个字符是基于特征序列"n"a"c"和这个时间步的标签"h"生成的。</p>
<h4 id="困惑度perplexity">困惑度（Perplexity）</h4>
<p>可以理解为"下一个词元的实际选择数的调和平均数"，用于<strong>评价语言模型的质量</strong></p>
<ul>
<li>在最好的情况下，模型总是完美地估计标签词元的概率为1。
在这种情况下，模型的困惑度为1。</li>
<li>在最坏的情况下，模型总是预测标签词元的概率为0。
在这种情况下，困惑度是正无穷大。</li>
<li>在基线上，该模型的预测是词表的所有可用词元上的均匀分布。
在这种情况下，困惑度等于词表中唯一词元的数量。
事实上，如果我们在没有任何压缩的情况下存储序列，
这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的上限，
而任何实际模型都必须超越这个上限。</li>
</ul>
<h4 id="从零实现循环神经网络模型">从零实现循环神经网络模型</h4>
<ol type="1">
<li><p>模型包括3个部分：</p>
<ol type="1">
<li><p>输入编码</p>
<p>将每个词元表示为更具表现力的特征向量，最简单的方式为<em>独热编码</em>（one-hot
encoding）</p></li>
<li><p>循环神经网络模型</p>
<p>实现以下公式： <span class="math display">\[
\mathbf{H}_t=\phi(\mathbf{X}_t\mathbf{W}_{xh}+\mathbf{H}_{t-1}\mathbf{W}_{hh}+\mathbf{b}_h).
\]</span></p></li>
<li><p>输出生成</p></li>
</ol></li>
<li><p>训练过程的特点：</p>
<ol type="1">
<li>隐状态初始化：选择随机采样or顺序分区</li>
<li>裁剪梯度：在更新模型参数之前需要裁剪梯度。
目的是：即使训练过程中某个点上发生了梯度爆炸，也能保证模型不会发散。</li>
<li>模型评估：用困惑度来评价模型，确保了不同长度的序列具有可比性。</li>
</ol></li>
</ol>
<h4 id="通过时间反向传播">通过时间反向传播</h4>
<ol type="1">
<li>“通过时间反向传播”仅仅适用于反向传播在具有隐状态的序列模型。</li>
<li>截断是计算方便性和数值稳定性的需要。截断包括：规则截断和随机截断。</li>
<li>矩阵的高次幂可能导致神经网络特征值的发散或消失，将以梯度爆炸或梯度消失的形式表现。</li>
<li>为了计算的效率，“通过时间反向传播”在计算期间会缓存中间值。</li>
</ol>
<h2 id="现代循环神经网络">现代循环神经网络</h2>
<h3 id="门控循环单元gru">门控循环单元(GRU)</h3>
<p>门控循环单元具有以下两个显著特征：</p>
<ul>
<li><strong>重置门有助于捕获序列中的短期依赖关系；</strong></li>
<li><strong>更新门有助于捕获序列中的长期依赖关系。</strong></li>
</ul>
<h4 id="门控隐状态">门控隐状态</h4>
<p>门控循环单元与普通的循环神经网络之间的关键区别在于：
前者支持隐状态的门控。
这意味着模型有专门的机制来确定应该何时更新隐状态，
以及应该何时重置隐状态，且这些机制是可学习的。</p>
<h5 id="重置门和更新门">重置门和更新门</h5>
<p>重置门允许我们控制“可能还想记住”的过去状态的数量；
更新门将允许我们控制新状态中有多少个是旧状态的副本。</p>
<p>下图描述了门控循环单元中的重置门和更新门的输入，
输入是由当前时间步的输入和前一时间步的隐状态给出。
两个门的输出是由使用sigmoid激活函数的两个全连接层给出。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161646642.png"
alt="在门控循环单元模型中计算重置门和更新门" />
<figcaption
aria-hidden="true">在门控循环单元模型中计算重置门和更新门</figcaption>
</figure>
<p>对于给定的时间步<span
class="math inline">\(t\)</span>，假设输入是一个小批量 <span
class="math inline">\(\mathbf{X}_t\in\mathbb{R}^{n\times
d}\)</span>(样本个数<span class="math inline">\(n\)</span>,输入个数<span
class="math inline">\(d\)</span>)，上一个时间步的隐状态是 <span
class="math inline">\(\mathbf{H}_{t-1}\in\mathbb{R}^{n\times
h}\quad(\)</span>隐藏单元个数<span class="math inline">\(h)\)</span>
。那么，重置门<span
class="math inline">\(\mathbf{R}_t\in\mathbb{R}^{n\times h}\)</span>和
更新门<span class="math inline">\(\mathbf{Z}_t\in\mathbb{R}^{n\times
h}\)</span>的计算如下所示：</p>
<p><span class="math display">\[
\begin{gathered}
\mathbf{R}_{t}
=\sigma(\mathbf{X}_t\mathbf{W}_{xr}+\mathbf{H}_{t-1}\mathbf{W}_{hr}+\mathbf{b}_r),
\\
\mathbf{Z}_{t}
=\sigma(\mathbf{X}_t\mathbf{W}_{xz}+\mathbf{H}_{t-1}\mathbf{W}_{hz}+\mathbf{b}_z),
\end{gathered}
\]</span></p>
<p>其中<span
class="math inline">\(\mathbf{W}_{xr},\mathbf{W}_{xz}\in\mathbb{R}^{d\times
h}\)</span>和<span
class="math inline">\(\mathbf{W}_{hr},\mathbf{W}_{hz}\in\mathbb{R}^{h\times
h}\)</span>是权重参数，<span
class="math inline">\(\mathbf{b}_r,\mathbf{b}_z\in\mathbb{R}^{1\times
h}\)</span>是偏置参数。在求和过程中会触发广播机制；我们使用sigmoid函数将输入值转换到区间(0,1)。</p>
<h5 id="候选隐状态">候选隐状态</h5>
<p>将重置门<span
class="math inline">\(R_t\)</span>与常规隐状态更新机制<span
class="math inline">\(\mathbf{H}_t=\phi(\mathbf{X}_t\mathbf{W}_{xh}+\mathbf{H}_{t-1}\mathbf{W}_{hh}+\mathbf{b}_h)\)</span>集成，得到在时间步<span
class="math inline">\(t\)</span>的<em>候选隐状态（candidate hidden
state）</em><span
class="math inline">\(\mathbf{\tilde{H}}_t\in\mathbb{R}^{n\times
h}\)</span> <span class="math display">\[
\tilde{\mathbf{H}}_t=\tanh(\mathbf{X}_t\mathbf{W}_{xh}+(\mathbf{R}_t\odot\mathbf{H}_{t-1})\mathbf{W}_{hh}+\mathbf{b}_h),
\]</span> 其中<span
class="math inline">\(\mathbf{W}_{xh}\in\mathbb{R}^{d\times
h}\)</span>和<span
class="math inline">\(\mathbf{W}_{hh}\in\mathbb{R}^{h\times
h}\)</span>是权重参数，<span
class="math inline">\(\mathbf{b}_h\in\mathbb{R}^{1\times
h}\)</span>是偏置项，符号©是Hadamard积
(按元素乘积)运算符。在这里，我们使用tanh非线性激活函数来确保候选隐状态中的值保持在区间(-1,1)中。</p>
<ul>
<li>与常规隐状态更新机制<span
class="math inline">\(\mathbf{H}_t=\phi(\mathbf{X}_t\mathbf{W}_{xh}+\mathbf{H}_{t-1}\mathbf{W}_{hh}+\mathbf{b}_h)\)</span>相比，新的候选隐状态公式中<span
class="math inline">\((\mathbf{R}_t\odot\mathbf{H}_{t-1})\)</span>可以减少以往状态的影响。</li>
<li>当重置门<span
class="math inline">\(\mathbf{R}_t\)</span>中接近1时，我们恢复一个如
<span
class="math inline">\(\mathbf{H}_t=\phi(\mathbf{X}_t\mathbf{W}_{xh}+\mathbf{H}_{t-1}\mathbf{W}_{hh}+\mathbf{b}_h)\)</span>的普通的循环神经网络<strong>=》重置门打开时，门控循环单元包含基本循环神经网络。</strong></li>
<li>对于重置门<span
class="math inline">\(\mathbf{R}_t\)</span>中所有接近0的项，候选隐状态是以<span
class="math inline">\(\mathbf{X}_t\)</span>作为输入的多层感知机的结果。因此，任何预先存在的隐状态都会被重置为默认值。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161646882.png"
alt="在门控循环单元模型中计算候选隐状态" />
<figcaption
aria-hidden="true">在门控循环单元模型中计算候选隐状态</figcaption>
</figure>
<h5 id="隐状态">隐状态</h5>
<p>上述的计算结果只是候选隐状态，还需要结合更新门<span
class="math inline">\(\mathbf{Z}_t\)</span>，从而确定新的隐状态<span
class="math inline">\(\mathbf{H}_t\in\mathbb{R}^{n\times h}\)</span>
在多大程度上来自旧的状态<span
class="math inline">\(\mathbf{H}_{t-1}\)</span>和 新的候选状态<span
class="math inline">\(\tilde{\mathbf{H}}_{t}\)</span> 。更新门<span
class="math inline">\(\mathbf{Z}_t\)</span>仅需要在 <span
class="math inline">\(\mathbf{H}_{t-1}\)</span>和<span
class="math inline">\(\tilde{\mathbf{H}}_t\)</span>
之间进行按元素的凸组合就可以实现这个目标。这就得出了门控循环单元的最终更新公式：</p>
<p><span class="math display">\[
\mathbf{H}_t=\mathbf{Z}_t\odot\mathbf{H}_{t-1}+(1-\mathbf{Z}_t)\odot\mathbf{\tilde{H}}_t.
\]</span></p>
<ul>
<li>当更新门<span
class="math inline">\({\mathbf{Z}}_t\)</span>接近1时，模型就倾向只保留旧状态。此时，来自<span
class="math inline">\(\mathbf{X}_t\)</span>的信息基本上被忽略，从而有效地跳过了依赖链条中的时间步<span
class="math inline">\(t\)</span>。<strong>更新门打开时，门控循环单元可以跳过子序列。</strong></li>
<li>相反，当<span
class="math inline">\({\mathbf{Z}}_t\)</span>接近0时，新的隐状态<span
class="math inline">\({\mathbf{H}}_t\)</span>就会接近候选隐状态<span
class="math inline">\(\tilde{\mathbf{H}}_{t}\)</span>。</li>
<li>这些设计可以帮助我们处理循环神经网络中的<strong>梯度消失</strong>问题，并更好地<strong>捕获时间步距离很长的序列的依赖关系</strong>。例如，如果整个子序列的所有时间步的更新门都接近于1，则无论序列的长度如何，在序列起始时间步的旧隐状态都将很容易保留并传递到序列结束。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161647038.png"
alt="计算门控循环单元模型中的隐状态" />
<figcaption
aria-hidden="true">计算门控循环单元模型中的隐状态</figcaption>
</figure>
<h3 id="长短期记忆网络lstm">长短期记忆网络(LSTM)</h3>
<p>长短期记忆网络的隐藏层输出包括“隐状态”和“记忆元”。<u><strong>只有隐状态会传递到输出层，而记忆元完全属于内部信息。</strong></u></p>
<ol type="1">
<li><strong>记忆元（memory cell
）</strong>：是LSTM的<strong>核心</strong>部分，它的主要功能是<strong>存储过去的信息。</strong>记忆单元内部包含一个称为“细胞状态”的向量，它可以在多个时间步之间保存和传递信息。<strong>记忆单元中的sigmoid激活门控单元（例如输入门，遗忘门和输出门）控制信息的存储、读取和遗忘，使得LSTM网络有能力选择性地记住或遗忘历史信息。</strong></li>
<li><strong>隐状态</strong>：是LSTM的<strong>输出</strong>部分。在每个时间步，LSTM都会根据当前的输入和过去的隐状态来更新其记忆元，并产生新的隐状态。这个隐状态既反映了当前时间步的输出，也存储了过去的信息，用于产生下一个时间步的输出。</li>
</ol>
<p>可以理解为：在LSTM模型中，记忆元主要负责存储长期的信息，而隐状态则主要反映短期的动态信息。</p>
<ul>
<li>记忆元中的信息可以经过多个时间步长久地保留，直到模型认为需要忘记这些信息，这就是所谓的“长期记忆”。</li>
<li>而隐状态则在每个时间步都会有所更新，既包含了一些过去的信息，又包新的输入信息，这就是所谓的“短期记忆”。只有当这种短期记忆与任务目标密切相关时，它才会被保存到长期记忆中。</li>
</ul>
<h4 id="门控记忆元">门控记忆元</h4>
<ol type="1">
<li>记忆元（memory cell 或 cell）是隐状态的一种特殊类型，
它们与隐状态具有相同的形状，其设计目的是用于记录附加的信息。</li>
<li>为了控制记忆元，我们需要许多门。
<ul>
<li><em>输出门</em>（output gate）：用来从<em>输出门</em>（output
gate）中输出条目</li>
<li><em>输入门</em>（input gate）：用来决定何时将数据读入记忆元</li>
<li><em>遗忘门</em>（forget
gate）：用来重置记忆元的内容，决定什么时候记忆或忽略记忆元中的输入</li>
</ul></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161647721.png"
alt="长短期记忆模型中的输入门、遗忘门和输出门" />
<figcaption
aria-hidden="true">长短期记忆模型中的输入门、遗忘门和输出门</figcaption>
</figure>
<h5 id="输入门遗忘门和输出门">输入门、遗忘门和输出门</h5>
<p>我们来细化一下长短期记忆网络的数学表达。假设有<span
class="math inline">\(h\)</span>个隐藏单元，批量大小为<span
class="math inline">\(n\)</span>,输入数为<span
class="math inline">\(d\)</span>。因此，输入为<span
class="math inline">\(\mathbf{X}_t\in\mathbb{R}^{n\times d}\)</span>,
前一时间步的隐状态为<span
class="math inline">\(\mathbf{H}_{t-1}\in\mathbb{R}^{n\times
h}\)</span>。相应地，时间步<span
class="math inline">\(t\)</span>的门被定义如下：输入门是<span
class="math inline">\(\mathbf{I}_t\in\mathbb{R}^{n\times h}\)</span>,
遗忘门是<span class="math inline">\(\mathbf{F}_t\in\mathbb{R}^{n\times
h}\)</span>, 输出门是<span
class="math inline">\(\mathbf{O}_t\in\mathbb{R}^{n\times
h}\)</span>。它们的计算方法如下： <span class="math display">\[
\begin{gathered}
I_{t}
=\sigma(\mathbf{X}_t\mathbf{W}_{xi}+\mathbf{H}_{t-1}\mathbf{W}_{hi}+\mathbf{b}_i),
\\
\mathbf{F}_{t}
=\sigma(\mathbf{X}_t\mathbf{W}_{xf}+\mathbf{H}_{t-1}\mathbf{W}_{hf}+\mathbf{b}_f),
\\
\mathbf{0}_{t}
=\sigma(\mathbf{X}_t\mathbf{W}_{xo}+\mathbf{H}_{t-1}\mathbf{W}_{ho}+\mathbf{b}_o),
\end{gathered}
\]</span> 其中<span
class="math inline">\(\mathbf{W}_{xi},\mathbf{W}_{xf},\mathbf{W}_{xo}\in\mathbb{R}^{d\times
h}\)</span>和<span
class="math inline">\(\mathbf{W}_{hi},\mathbf{W}_{hf},\mathbf{W}_{ho}\in\mathbb{R}^{h\times
h}\)</span>是权重参数，<span
class="math inline">\(\mathbf{b}_i,\mathbf{b}_f,\mathbf{b}_o\in\mathbb{R}^{1\times
h}\)</span>是偏置参数。</p>
<h5 id="候选记忆元">候选记忆元</h5>
<p>这里的候选记忆元对应了“短期记忆”的概念。</p>
<p>LSTM模型接收一个新的输入，并结合前一时间步的隐藏状态来更新当前的隐藏状态。这个更新过程就像是对过去信息（即前一时间步的隐藏状态）和新输入信息的一个融合，所以说隐藏状态既包含了一些过去的信息，也包含新的输入信息。这个过程对应了“短期记忆”的概念。</p>
<p>候选记忆元(candidate memory cell) <span
class="math inline">\(\tilde{\mathcal{C}}_t\in\mathbb{R}^{n\times
h}\)</span>使用tanh函数作为激活函数，函数的值范围为(-1,1)。下面导出在时间步<span
class="math inline">\(t\)</span>处的方程：</p>
<p><span class="math display">\[
\tilde{\mathbf{C}}_t=\tanh(\mathbf{X}_t\mathbf{W}_{xc}+\mathbf{H}_{t-1}\mathbf{W}_{hc}+\mathbf{b}_c),
\]</span></p>
<p>其中<span class="math inline">\(\mathbf{W}_{xc}\in\mathbb{R}^{d\times
h}\)</span>和<span
class="math inline">\(\mathbf{W}_{hc}\in\mathbb{R}^{h\times
h}\)</span>是权重参数，<span
class="math inline">\(\mathbf{b}_c\in\mathbb{R}^{1\times
h}\)</span>是偏置参数。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161648054.png"
alt="长短期记忆模型中的候选记忆元" />
<figcaption aria-hidden="true">长短期记忆模型中的候选记忆元</figcaption>
</figure>
<h5 id="记忆元">记忆元</h5>
<ul>
<li><strong>输入门</strong>决定了新的输入信息在多大程度上被写到记忆单元中。如果输入门的值接近1，意味着新的输入信息会被存储到记忆单元里，成为“长期记忆”。</li>
<li><strong>遗忘门</strong>则对前一时间步的记忆单元进行操作，决定了哪部分历史信息将被遗忘。如果遗忘门的值接近0，那么对应的历史信息就会被遗忘，不再流入下一个时间步的记忆单元。</li>
</ul>
<p>在长短期记忆网络中，利用输入门和输出门来控制输入和遗忘(或跳过)：输入门<span
class="math inline">\(\mathbf{I}_t\)</span>控制采用多少来自<span
class="math inline">\(\tilde{\mathcal{C}}_t\)</span>的新数据，而遗忘门<span
class="math inline">\(\mathbf{F}_t\)</span>控制保留多少过去的记忆元<span
class="math inline">\(\mathbf{C}_{t-1}\in\mathbb{R}^{n\times
h}\)</span>的内容。使用按元素乘法，得出：</p>
<p><span class="math display">\[
\mathbf{C}_t=\mathbf{F}_t\odot\mathbf{C}_{t-1}+\mathbf{I}_t\odot\tilde{\mathbf{C}}_t.
\]</span> 如果遗忘门<span
class="math inline">\(\mathbf{F}_t\)</span>始终为1且输入门<span
class="math inline">\(\mathbf{I}_t\)</span>始终为0，则过去的记忆元<span
class="math inline">\(\mathcal{C}_{t-1}\)</span>将随时间被保存并传递到当前时间步。引入这种设计是为了缓解梯度消失问题，并更好地捕获序列中的长距离依赖关系。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161648363.png"
alt="在长短期记忆网络模型中计算记忆元" />
<figcaption
aria-hidden="true">在长短期记忆网络模型中计算记忆元</figcaption>
</figure>
<h4 id="隐状态-1">隐状态</h4>
<ul>
<li><strong>输出门决定了多少记忆元的信息会流向隐状态。</strong>具体来说，记忆元中的信息首先会与输出门的值（一个在0到1之间的数）相乘，得到的结果就是流向隐藏状态的信息。
<ul>
<li>如果输出门的值接近1，那么记忆元中的信息就几乎完整地流向隐状态；</li>
<li>如果输出门的值接近0，那么记忆元中的信息就几乎不会流向隐状态。</li>
</ul></li>
</ul>
<blockquote>
<p>这种通过输出门控制信息流向隐状态的机制，使得LSTM模型能够对前面的信息进行选择性的忽略或者强调。例如，在一些情况下，模型可能只需要关注记忆单元中的某一部分信息，那么输出门可以通过关闭（接近0）来阻止其他不相关信息流入隐状态；而在其他情况下，如果记忆单元中的所有信息都对当前任务很重要，那么输出门可以被打开（接近1），这样所有的信息都会流向隐状态。在处理自然语言的任务（如机器翻译、文本生成等）时，通过合理调整输出门的值，可以更好地控制长短语义的流动，从而捕捉到句子中更复杂、更深层次的语义关系。</p>
</blockquote>
<p>因此，隐状态<span
class="math inline">\(\mathbf{H}_t\in\mathbb{R}^{n\times
h}\)</span>计算公式为：</p>
<p><span class="math display">\[
\mathbf{H}_t=\mathbf{O}_t\odot\tanh(\mathbf{C}_t).
\]</span></p>
<p>只要输出门接近1，我们就能够有效地将所有记忆信息传递给预测部分，而对于输出门接近0，我们只保留记忆元内的所有信息，
而不需要更新隐状态。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161648548.png"
alt="在长短期记忆模型中计算隐状态" />
<figcaption aria-hidden="true">在长短期记忆模型中计算隐状态</figcaption>
</figure>
<h3 id="深度循环神经网络">深度循环神经网络</h3>
<p>（后续需要使用再学习）</p>
<h3 id="双向循环神经网络">双向循环神经网络</h3>
<p>（后续需要使用再学习）</p>
<h3 id="编码器-解码器架构">编码器-解码器架构</h3>
<p>为了处理长度可变的输入和输出序列（如机器翻译），设计了<em>编码器-解码器</em>（encoder-decoder）架构，包含两个主要组件：</p>
<p>（1）编码器（encoder）： 接受一个长度可变的序列作为输入，
并将其转换为具有固定形状的编码状态。</p>
<p>（2）解码器（decoder）：
将固定形状的编码状态映射到长度可变的序列。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161648190.png"
alt="编码器-解码器架构" />
<figcaption aria-hidden="true">编码器-解码器架构</figcaption>
</figure>
<h3 id="序列到序列学习seq2seg">序列到序列学习(seq2seg)</h3>
<p>（后续需要使用再学习）</p>
<h2 id="注意力机制">注意力机制</h2>
<p>注意力框架=》注意力函数=》仅仅基于注意力机制的Transformer架构</p>
<h3 id="注意力提示">注意力提示</h3>
<h4 id="双组件two-component框架">双组件（two-component）框架</h4>
<p>受试者基于<em>非自主性提示</em>和<em>自主性提示</em>
有选择地引导注意力的焦点。（心理学）</p>
<ul>
<li>非自主性提示：基于环境中物体的突出性和易见性</li>
<li>自主性提示：依赖于认知和意识的控制</li>
</ul>
<h4 id="查询键和值">查询、键和值</h4>
<ul>
<li>在注意力机制的背景下，自主性提示被称为<em>查询</em>（query）</li>
<li>感官输入被称为<em>值</em>（value）</li>
<li>每个值都与一个<em>键</em>（key）配对，
这可以想象为感官输入的非自主提示。</li>
</ul>
<p>给定任何查询，注意力机制通过<em>注意力汇聚</em>（attention pooling）
将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。</p>
<p>如下图所示，可以通过设计注意力汇聚的方式，
便于给定的查询（自主性提示）与键（非自主性提示）进行匹配，
这将引导得出最匹配的值（感官输入）。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161649624.png"
alt="注意力机制通过注意力汇聚将查询（自主性提示）和键（非自主性提示）结合在一起，实现对值（感官输入）的选择倾向" />
<figcaption
aria-hidden="true">注意力机制通过注意力汇聚将<em>查询</em>（自主性提示）和<em>键</em>（非自主性提示）结合在一起，实现对<em>值</em>（感官输入）的选择倾向</figcaption>
</figure>
<p>查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；
注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出</p>
<h4 id="可视化注意力">可视化注意力</h4>
<p>注意力机制的可视化一般是通过<u>在源序列和目标序列之间展示一个<strong>热图</strong></u>，该热图的每个单元格<code>[i][j]</code>对应源序列中的第<code>i</code>个元素和目标序列中的第<code>j</code>个词的<strong><u>注意力分数</u></strong>。<u><strong>这个分数表明在生成目标序列的第j个词时模型对源序列中第i个词的关注程度</strong></u>。我们根据注意力分数，画出对应的颜色，数值越高，对应的颜色越明显（或者说越热）。</p>
<h3 id="注意力汇聚">注意力汇聚</h3>
<h4 id="非参数注意力汇聚">非参数注意力汇聚</h4>
<h5 id="nadaraya-watson核回归">Nadaraya-Watson核回归</h5>
<p>Nadaraya和 Watson提出根据输入的位置对输出<span
class="math inline">\(y_i\)</span>进行加权，来实现注意力汇聚。其中，K是核（kernel）。
<span class="math display">\[
f(x)=\sum_{i=1}^n\frac{K(x-x_i)}{\sum_{j=1}^nK(x-x_j)}y_i,
\]</span></p>
<h5
id="通用的注意力汇聚attention-pooling公式">通用的注意力汇聚（attention
pooling）公式</h5>
<p>由上述公式启发，写出更加<strong>通用的注意力汇聚（attention
pooling）公式：</strong> <span class="math display">\[
f(x)=\sum_{i=1}^n\alpha(x,x_i)y_i
\]</span> 其中，<span class="math inline">\(x\)</span>是查询，<span
class="math inline">\((x_i,y_i)\)</span>是键值对，将查询<span
class="math inline">\(x\)</span>和键<span
class="math inline">\(x_i\)</span>之间的关系建模为 注意力权重 (attention
weight) <span
class="math inline">\(\alpha(x,x_i)\)</span>，这个权重将被分配给每一个对应值<span
class="math inline">\(y_{i}\)</span>，因此注意力汇聚<span
class="math inline">\(f(x)\)</span>是<span
class="math inline">\(y_i\)</span>的加权平均。对于任何查询，模型在所有键值的注意力权重都是一个有效的概率分布：它们是非负的，并且总和为1。</p>
<h5 id="nadaraya-watson高斯核回归">Nadaraya-Watson高斯核回归</h5>
<p><strong>为了更好地理解注意力汇聚，考虑一个高斯核(Gaussian
kernel)，其定义为：</strong> <span class="math display">\[
K(u)=\frac1{\sqrt{2\pi}}\exp(-\frac{u^2}2).
\]</span> 将高斯核代上述"Nadaraya-Watson核回归公式"可以得到： <span
class="math display">\[
\begin{aligned}
f(x)&amp; =\sum_{i=1}^n\alpha(x,x_i)y_i  \\
&amp;=\sum_{i=1}^n\frac{\exp\left(-\frac12(x-x_i)^2\right)}{\sum_{j=1}^n\exp\left(-\frac12(x-x_j)^2\right)}y_i
\\
&amp;=\sum_{i=1}^n\text{softmax}\left(-\frac12(x-x_i)^2\right)y_i.
\end{aligned}
\]</span> 分析上式，可以得出：<strong>如果一个键<span
class="math inline">\(x_i\)</span>越是接近给定的查询<span
class="math inline">\(x\)</span>, 那么分配给这个键对应值<span
class="math inline">\(y_i\)</span>的注意力权重就会越大，也就“获得了更多的注意力”。</strong></p>
<blockquote>
<p>原因是：如果键<span
class="math inline">\(x_i\)</span>与查询x越接近，<span
class="math inline">\((x - x_i)^2\)</span>就越小，那么分子<span
class="math inline">\(\exp\left(-\frac12(x-x_i)^2\right)\)</span>的值就越大。虽然分母<span
class="math inline">\(\sum_{i=1}^n\exp\left(-\frac12(x-x_j)^2\right)\)</span>的值也会随着分子的变大而变大。然而，那么这个根据糖水不等式可知，最终该项的分数整体会更大，也就是分配给这个键对应值<span
class="math inline">\(y_i\)</span>的注意力权重就会越大，也就“获得了更多的注意力”。</p>
</blockquote>
<h4 id="带参数的注意力汇聚">带参数的注意力汇聚</h4>
<p>在下面的查询<span class="math inline">\(x\)</span>和键<span
class="math inline">\(x_i\)</span>之间的距离乘以可学习参数<span
class="math inline">\(w\)</span>： <span class="math display">\[
\begin{aligned}
f(x)&amp; =\sum_{i=1}^n\alpha(x,x_i)y_i  \\
&amp;=\sum_{i=1}^n\frac{\exp\left(-\frac12((x-x_i)w)^2\right)}{\sum_{j=1}^n\exp\left(-\frac12((x-x_j)w)^2\right)}y_i
\\
&amp;=\sum_{i=1}^n\text{softmax}\left(-\frac12((x-x_i)w)^2\right)y_i.
\end{aligned}
\]</span></p>
<h5 id="定义模型">定义模型</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入需要的模块</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NWKernelRegression</span>(nn.Module):</span><br><span class="line">    <span class="comment"># 初始化函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 创建一个模型参数w，初始化为随机数，需要求梯度</span></span><br><span class="line">        self.w = nn.Parameter(torch.rand((<span class="number">1</span>,), requires_grad=<span class="literal">True</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 前向传播函数，计算模型的输出</span></span><br><span class="line">    <span class="comment"># 输入参数是一组查询、键和对应的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values</span>):</span><br><span class="line">        <span class="comment"># 将queries张量扩展并重组其形状，使其与keys张量的形状匹配，这主要是为了计算每个查询与所有键的差异</span></span><br><span class="line">        queries = queries.repeat_interleave(keys.shape[<span class="number">1</span>]).reshape((-<span class="number">1</span>, keys.shape[<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算attention weights，使用softmax函数将权重标准化到0-1范围内，并且保证所有权重之和为1</span></span><br><span class="line">        self.attention_weights = nn.functional.softmax(</span><br><span class="line">            -((queries - keys) * self.w)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用attention weights对值进行加权平均</span></span><br><span class="line">        <span class="comment"># 首先，我们使用unsqueeze函数为values和attention weights增加一个维度</span></span><br><span class="line">        <span class="comment"># 这样，我们可以借助torch.bmm函数，对每一对查询和键-值对进行加权平均</span></span><br><span class="line">        <span class="comment"># 最后，使用reshape函数将结果张量的形状重新调整为与查询相同的形状</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.attention_weights.unsqueeze(<span class="number">1</span>),</span><br><span class="line">                         values.unsqueeze(-<span class="number">1</span>)).reshape(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4
id="对比非参数和带参数的注意力汇聚">对比非参数和带参数的注意力汇聚</h4>
<p><strong>非参数的注意力汇聚</strong>
如果有足够的数据，模型会收敛到最优结果。</p>
<p><strong>带参数的注意力汇聚</strong>在尝试拟合带噪声的训练数据时，
预测结果不如之前非参数模型的平滑。</p>
<h3 id="注意力评分函数">注意力评分函数</h3>
<h4 id="引入-1">引入</h4>
<p>【注意力汇聚】小节<strong>使用了高斯核来对查询和键之间的关系建模</strong>。
<span class="math display">\[
\begin{aligned}
f(x)
&amp;=\sum_{i=1}^n\frac{\exp\left(-\frac12((x-x_i)w)^2\right)}{\sum_{j=1}^n\exp\left(-\frac12((x-x_j)w)^2\right)}y_i
\\
&amp;=\sum_{i=1}^n\text{softmax}\left(-\frac12((x-x_i)w)^2\right)y_i.
\end{aligned}
\]</span></p>
<ul>
<li>其中的高斯核指数部分<span
class="math inline">\(-\frac12((x-x_i)w)^2\)</span>可以视为<em>注意力评分函数</em>（attention
scoring function），简称<em>评分函数</em>（scoring function）</li>
<li>然后，把这个函数的输出结果输入到softmax函数中进行运算，将得到与键对应的值的概率分布（即注意力权重）</li>
<li>最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161649078.png"
alt="计算注意力汇聚的输出为值的加权和" />
<figcaption
aria-hidden="true">计算注意力汇聚的输出为值的加权和</figcaption>
</figure>
<h4 id="数学描述">数学描述</h4>
<blockquote>
<p>用数学语言描述，假设有一个查询<span
class="math inline">\(\mathbf{q}\in\mathbb{R}^q\)</span>和 <span
class="math inline">\(m\)</span>个“键-值"对 <span
class="math inline">\((\mathbf{k}_1,\mathbf{v}_1),\ldots,(\mathbf{k}_m,\mathbf{v}_m)\)</span>,
其中<span class="math inline">\(\mathbf{k}_i\in\mathbb{R}^k\)</span>,
<span
class="math inline">\(\mathbf{v}_i\in\mathbb{R}^v\)</span>。注意力汇聚函数<span
class="math inline">\(f\)</span>就被表示成值的加权和：</p>
</blockquote>
<p><span class="math display">\[
f(\mathbf{q},(\mathbf{k}_1,\mathbf{v}_1),\ldots,(\mathbf{k}_m,\mathbf{v}_m))=\sum_{i=1}^m\alpha(\mathbf{q},\mathbf{k}_i)\mathbf{v}_i\in\mathbb{R}^v,
\]</span></p>
<ul>
<li>观察公式，理解为：通过查询<span
class="math inline">\(q\)</span>和键<span
class="math inline">\(k_i\)</span>的匹配度，得出不同的注意力权重<span
class="math inline">\(\alpha\)</span>，从而对与键<span
class="math inline">\(k_i\)</span>对应的值<span
class="math inline">\(v_i\)</span>产生不同的注意力</li>
</ul>
<blockquote>
<p>其中查询<span class="math inline">\(\mathbf{q}\)</span>和键<span
class="math inline">\(\mathbf{k}_i\)</span>的注意力权重(标量)
是通过注意力评分函数<span
class="math inline">\(a\)</span>将两个向量映射成标量，再经过softmax运算得到的：</p>
</blockquote>
<p><span class="math display">\[
\alpha(\mathbf{q},\mathbf{k}_i)=\mathrm{softmax}(a(\mathbf{q},\mathbf{k}_i))=\frac{\exp(a(\mathbf{q},\mathbf{k}_i))}{\sum_{j=1}^m\exp(a(\mathbf{q},\mathbf{k}_j))}\in\mathbb{R}.
\]</span></p>
<p><strong>因此，选择不同的注意力评分函数<span
class="math inline">\(a\)</span>会导致不同的注意力汇聚操作</strong>。<u>下面将介绍两个流行的评分函数，
稍后将用他们来实现更复杂的注意力机制。</u></p>
<h4 id="常用评分函数">常用评分函数</h4>
<h5 id="加性注意力">加性注意力</h5>
<p>一般来说，当查询和键是不同长度的矢量时，可以使用加性注意力作为评分函数。给定查询<span
class="math inline">\(\mathbf{q}\in\mathbb{R}^q\)</span>和 键<span
class="math inline">\(\mathbf{k}\in\mathbb{R}^k\)</span>, 加性注意力
(additive attention) 的评分函数为</p>
<p><span class="math display">\[
a(\mathbf{q},\mathbf{k})=\mathbf{w}_v^\top\mathrm{tanh}(\mathbf{W}_q\mathbf{q}+\mathbf{W}_k\mathbf{k})\in\mathbb{R},
\]</span></p>
<ul>
<li>其中可学习的参数是<span
class="math inline">\(\mathbf{W}_q\in\mathbb{R}^{h\times
q}\)</span>、<span
class="math inline">\(\mathbf{W}_k\in\mathbb{R}^{h\times
k}\)</span>和<span
class="math inline">\(\mathbf{w}_v\in\mathbb{R}^h\)</span>。</li>
<li>公式解释：将查询和键连结起来后输入到一个多层感知机(MLP)
中，感知机包含一个隐藏层，其隐藏单元数是一个超参数<span
class="math inline">\(h\)</span>，使用tanh作为激活函数，并且禁用偏置项。</li>
</ul>
<h5 id="缩放点积注意力">缩放点积注意力</h5>
<p><strong>查询和键具有相同的长度<span
class="math inline">\(d\)</span>（前提条件），</strong>可以使用点积这一计算效率更高的评分函数。</p>
<blockquote>
<p>假设查询和键的所有元素都是独立的随机变量，并且都满足零均值和单位方差，那么两个向量的点积的均值为0，方差为<span
class="math inline">\(d\)</span>
。为确保无论向量长度如何，点积的方差在不考虑向量长度的情况下仍然是1，我们再将点积除以<span
class="math inline">\(\sqrt d\)</span>，则缩放点积注意力 (scaled
dot-product attention) 评分函数为：</p>
</blockquote>
<p><span class="math display">\[
a(\mathbf{q},\mathbf{k})=\mathbf{q}^\top\mathbf{k}/\sqrt d.
\]</span></p>
<blockquote>
<p>在实践中，我们通常从小批量的角度来考虑提高效率，例如基于<span
class="math inline">\(n\)</span>个查询和<span
class="math inline">\(m\)</span>个键一值对计算注意力，其中查询和键的长度为<span
class="math inline">\(d\)</span>,值的长度为<span
class="math inline">\(v\)</span>。查询<span
class="math inline">\(\mathbf{Q}\in\mathbb{R}^{n\times
d}\)</span>、键<span
class="math inline">\(\mathbf{K}\in\mathbb{R}^{m\times d}\)</span>和
值<span class="math inline">\(\mathbf{V}\in\mathbb{R}^{m\times
v}\)</span>的缩放点积注意力是：</p>
</blockquote>
<p><span class="math display">\[
\operatorname{softmax}\left(\frac{\mathbf{QK}^\top}{\sqrt{d}}\right)\mathbf{V}\in\mathbb{R}^{n\times
v}.
\]</span></p>
<h3 id="bahdanau-注意力">Bahdanau 注意力</h3>
<h4 id="引入-2">引入</h4>
<p>在机器翻译问题中：通过设计一个基于两个循环神经网络的编码器-解码器架构，
用于序列到序列学习。</p>
<p>具体来说，循环神经网络<u>编码器</u>将长度可变的序列转换为<strong><u>固定形状的上下文变量</u></strong>，
然后循环神经网络<u>解码器</u>根据<u>生成的词元和上下文变量</u>
按词元生成输出（目标）序列词元。然而，并非所有输入（源）词元都对解码某个词元有用，
那么<u><strong>在每个解码步骤中使用编码不同的上下文变量</strong></u>是否会更合理呢？</p>
<p>在这里，我们可以将<strong>上下文变量</strong>视为注意力集中的输出。
<u>在预测词元时，如果不是所有输入词元都相关，模型将仅对齐输入序列中与当前预测相关的部分。</u></p>
<h4 id="bahdanau-注意力模型">Bahdanau 注意力模型</h4>
<blockquote>
<p>原来的机器翻译问题中，解码器的隐藏层的变换为： <span
class="math display">\[
\mathbf{s}_{t^{\prime}}=g(y_{t^{\prime}-1},\mathbf{c},\mathbf{s}_{t^{\prime}-1}).
\]</span> 在输出序列上的任意时间步<span
class="math inline">\(t^{\prime}\)</span>,
循环神经网络将来自上一时间步的输出<span
class="math inline">\(y_{t^{\prime}-1}\)</span> 和上下文变量<span
class="math inline">\(c\)</span>作为其输入，然后在当前时间步将它们和上一隐状态
<span class="math inline">\(\mathfrak{s}_{t^{\prime}-1}\)</span>转换为
隐状态<span class="math inline">\(s_{t^{\prime}}\)</span>。</p>
</blockquote>
<p>在理解上述<strong>【引入】</strong>部分的思路后，假设输入序列中有<span
class="math inline">\(T\)</span>个词元，解码时间步<span
class="math inline">\(t^{\prime}\)</span>的上下文变量是注意力集中的输出：
<span class="math display">\[
\mathbf{c}_{t^{\prime}}=\sum_{t=1}^T\alpha(\mathbf{s}_{t^{\prime}-1},\mathbf{h}_t)\mathbf{h}_t,
\]</span> 其中，时间步<span
class="math inline">\(t^{\prime}-1\)</span>时的解码器隐状态<span
class="math inline">\(\mathfrak{s}_{t^{\prime}-1}\)</span>是查询，编码器隐状态<span
class="math inline">\(\mathfrak{h}_t\)</span>既是键，也是值，注意力权重<span
class="math inline">\(\alpha\)</span>是使用加性注意力打分函数计算的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161649438.png"
alt="一个带有Bahdanau注意力的循环神经网络编码器-解码器模型" />
<figcaption
aria-hidden="true">一个带有Bahdanau注意力的循环神经网络编码器-解码器模型</figcaption>
</figure>
<h4 id="定义注意力解码器">定义注意力解码器</h4>
<p>定义Bahdanau注意力，实现循环神经网络编码器-解码器。</p>
<ol type="1">
<li>首先，初始化解码器的状态，需要下面的输入：
<ul>
<li><strong>用</strong><u>编码器在所有时间步的最终层隐状态</u><strong>作为</strong><u>注意力的键和值</u></li>
<li><strong>用</strong><u>上一时间步的编码器全层隐状态</u><strong>作为</strong><u>初始化解码器的隐状态</u></li>
<li>编码器有效长度（排除在注意力池中填充词元）</li>
</ul></li>
<li>其次，进行查询
<ul>
<li>在每个解码时间步骤中，解码器上一个时间步的最终层隐状态将用作查询。</li>
</ul></li>
</ol>
<h3 id="多头注意力">多头注意力</h3>
<h4 id="引入-3">引入</h4>
<blockquote>
<p>在实践中，当给定相同的查询、键和值的集合时，我们希望模型可以基于相同的注意力机制学习到不同的行为，然后将不同的行为作为知识组合起来，捕获序列内各种范围的依赖关系
(例如，短距离依赖和长距离依赖关系)。因此，允许注意力机制组合使用查询、键和值的不同
子空间表示 (representation subspaces) 可能是有益的。</p>
</blockquote>
<blockquote>
<p>为此，与其只使用单独一个注意力汇聚，我们可以用独立学习得到的<span
class="math inline">\(h\)</span>组不同的 线性投影 (linear projections)
来变换查询、键和值。然后，这<span
class="math inline">\(h\)</span>组变换后的查询、键和值将并行地送到注意力汇聚中。最后，将这<span
class="math inline">\(h\)</span>个注意力汇聚的输出拼接在一起，并且通过另一个可以学习的线性投影进行变换，以产生最终输出。</p>
</blockquote>
<blockquote>
<p>这种设计被称为多头注意力 (multihead attention) 。对于<span
class="math inline">\(h\)</span>个注意力汇聚输出，
每一个注意力汇聚都被称作一个头(head)。多头注意力融合了来自于多个注意力汇聚的不同知识，这些知识的不同来源于相同的查询、键和值的不同的子空间表示。</p>
</blockquote>
<blockquote>
<p>下图展示了使用全连接层来实现可学习的线性变换的多头注意力。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161649564.png"
alt="多头注意力：多个头连结然后线性变换" />
<figcaption
aria-hidden="true">多头注意力：多个头连结然后线性变换</figcaption>
</figure>
<h4 id="数学描述-1">数学描述</h4>
<p>用数学语言描述上述多头注意力模型：</p>
<blockquote>
<p>给定查询<span
class="math inline">\(\mathbf{q}\in\mathbb{R}^{d_q}\)</span>、键<span
class="math inline">\(\mathbf{k}\in\mathbb{R}^{d_k}\)</span>和 值<span
class="math inline">\(\mathbf{v}\in\mathbb{R}^{d_v}\)</span>,
每个注意力头<span
class="math inline">\(\mathbf{h}_i\quad(i=1,\ldots,h)\)</span>
的计算方法为：</p>
</blockquote>
<p><span class="math display">\[
\mathbf{h}_i=f(\mathbf{W}_i^{(q)}\mathbf{q},\mathbf{W}_i^{(k)}\mathbf{k},\mathbf{W}_i^{(v)}\mathbf{v})\in\mathbb{R}^{p_v},
\]</span></p>
<blockquote>
<p>其中，可学习的参数包括<span
class="math inline">\(\mathbf{W}_i^{(q)}\in\mathbb{R}^{p_q\times
d_q}\text{、}\mathbf{W}_i^{(k)}\in\mathbb{R}^{p_k\times d_k}\text{和
}\mathbf{W}_i^{(v)}\in\mathbb{R}^{p_v\times
d_v}\)</span>，以及代表注意力汇聚的函数<span
class="math inline">\(f\)</span>。<u><span
class="math inline">\(f\)</span>可以是加性注意力和缩放点积注意力。</u></p>
</blockquote>
<blockquote>
<p>多头注意力的输出需要经过另一个线性转换，它对应着<span
class="math inline">\(h\)</span>个头连结后的结果，因此其可学习参数是
<span class="math inline">\(\mathbf{W}_o\in\mathbb{R}^{p_o\times
hp_v}:\)</span></p>
</blockquote>
<p><span class="math display">\[
\mathbf{W}_o\begin{bmatrix}\mathbf{h}_1\\\vdots\\\mathbf{h}_h\end{bmatrix}\in\mathbb{R}^{p_o}.
\]</span>
基于这种设计，<strong>每个头都可能会关注输入的不同部分</strong>，从而可以表示比简单加权平均值更复杂的函数。</p>
<h3 id="自注意力和位置编码">自注意力和位置编码</h3>
<h4 id="引入-4">引入</h4>
<p>在深度学习中，经常使用卷积神经网络(CNN)或循环神经网络(RNN)对序列进行编码。<u><strong>有了注意力机制之后，我们将词元序列输入注意力池化中，以便同一组词元同时充当查询、键和值。</strong></u><u>具体来说，每个查询都会关注所有的键一值对并生成一个注意力输出</u>。<strong><u>由于查询、键和值来自同一组输入，因此被称为
自注意力 (self-attention)</u></strong> ，也被称为内部注意力
(intra-attention)。</p>
<h4 id="自注意力">自注意力</h4>
<p>给定一个由词元组成的输入序列<span
class="math inline">\(\mathbf{x}_1,\ldots,\mathbf{x}_n\)</span>,
其中任意<span
class="math inline">\(\mathbf{x}_i\in\mathbb{R}^d\quad(1\leq i\leq
n)\)</span> 。该序列的自注意力输出为一个长度相同的序列 <span
class="math inline">\(\mathbf{y}_1,\ldots,\mathbf{y}_n\)</span>,其中：</p>
<p><span class="math display">\[
\mathbf{y}_i=f(\mathbf{x}_i,(\mathbf{x}_1,\mathbf{x}_1),\ldots,(\mathbf{x}_n,\mathbf{x}_n))\in\mathbb{R}^d
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attention = d2l.MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,</span><br><span class="line">                                   num_hiddens, num_heads, <span class="number">0.5</span>)</span><br><span class="line">attention(X, X, X, valid_lens).shape</span><br></pre></td></tr></table></figure>
<p>MultiHeadAttention模型在接收输入时，传入的查询（query）、键（key）和值（value）都是相同的张量X。这意味着模型在计算注意力分数时，<strong><u>输入序列的各个元素同时扮演了查询、键和值的角色</u></strong>，也就是自己对自己进行注意力计算，因此被称为"自注意力"。</p>
<h4
id="比较卷积神经网络循环神经网络和自注意力">比较卷积神经网络、循环神经网络和自注意力</h4>
<p>比较卷积神经网络、循环神经网络和自注意力这3种架构的计算复杂性、顺序操作和最大路径长度。</p>
<ol type="1">
<li><strong>计算复杂性：</strong>
指进行运算所需要的计算量。我们通常希望计算复杂性越低越好，因为这意味着需要的计算资源更少，训练和预测的速度也更快。
<ul>
<li>卷积神经网络：计算复杂性为<span
class="math inline">\(O(knd^2)\)</span>，其中k是卷积核的大小，n是序列长度，d是输入和输出的通道数。换言之，卷积神经网络所需要的计算量与卷积核的大小、序列长度以及输入和输出的通道数有关。</li>
<li>循环神经网络：计算复杂性为<span
class="math inline">\(O(nd^2)\)</span>，其中n是序列长度，d是隐藏状态的维度。因此，循环神经网络所需要的计算量与序列长度和隐藏状态的维度有关。</li>
<li>自注意力机制：计算复杂性为<span
class="math inline">\(O(n^2d)\)</span>，其中n是序列长度，d是输入输出的维度。对于自注意力机制，计算量与序列长度的平方和输入输出的维度有关。</li>
</ul></li>
<li><strong>顺序操作：</strong>
顺序操作是指必须按照特定顺序进行的操作。顺序操作的数量越多，越难以进行并行计算，因此我们通常希望顺序操作越少越好。
<ul>
<li><strong>卷积神经网络和自注意力机制的顺序操作数量都为$ O
(1)$，也就是说，几乎不存在顺序操作，计算可以高度并行化。</strong></li>
<li>循环神经网络的顺序操作数量为<span class="math inline">\(O
(n)\)</span>，也就是说，它需要按照序列数据（长度为n）的顺序，一个接一个地处理每个元素——先处理第一个元素，然后处理第二个元素，然后处理第三个元素，依此类推。也就是说，无法同时处理所有的序列元素，因为每个步骤都依赖于前一个步骤的输出，因此无法进行完全的并行计算。这就导致了RNN的主要缺点——在处理长序列时可能会很慢，因为必须等待所有的顺序操作都完成才能得到最终的输出。</li>
</ul></li>
<li><strong>最大路径长度：</strong>
最大路径长度是指在网络中，从一个节点到另一个节点经过的最大路径长度。<strong>路径越短，网络学习序列中远距离依赖关系的能力越好。</strong>
<ul>
<li>卷积神经网络的最大路径长度为 <span class="math inline">\(O
(n/k)\)</span>，n是序列长度，k是卷积核的大小。</li>
<li>循环神经网络的最大路径长度为 <span class="math inline">\(O
(n)\)</span>，n是序列长度。</li>
<li><strong>自注意力机制的最大路径长度为 <span class="math inline">\(O
(1)\)</span>，也就是说，任何两个节点之间的距离都为 1。</strong></li>
</ul></li>
</ol>
<p>总结一下，<strong>卷积神经网络和自注意力机制可以进行高度的并行计算，而自注意力机制的最大路径长度最短。然而，自注意力机制的计算复杂性与序列长度的平方成正比，因此在处理长序列时可能会很慢。</strong></p>
<h4 id="位置编码">位置编码</h4>
<h5 id="引入-5">引入</h5>
<p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的，而自注意力则因为并行计算而放弃了顺序操作。<strong>为了使用序列的顺序信息，通过在输入表示中添加
位置编码 (positional encoding)
来注入绝对的或相对的位置信息。</strong>位置编码可以<u>通过学习得到</u>也可以<u>直接固定得到</u>。接下来介绍基于正弦函数和余弦函数的固定位置编码</p>
<h5
id="基于正弦函数和余弦函数的固定位置编码">基于正弦函数和余弦函数的固定位置编码</h5>
<blockquote>
<p>假设输入表示<span
class="math inline">\(\mathbf{X}\in\mathbb{R}^{n\times
d}\)</span>包含一个序列中<span
class="math inline">\(n\)</span>个词元的<span
class="math inline">\(d\)</span>维嵌入表示。位置编码使用相同形状的位置嵌入矩阵
<span class="math inline">\(\mathbf{P}\in\mathbb{R}^{n\times
d}\)</span>输出<span
class="math inline">\(\mathbf{X}+\mathbf{P}\)</span>, 矩阵第<span
class="math inline">\(i\)</span>行、第<span
class="math inline">\(2j\)</span>列和<span
class="math inline">\(2j+1\)</span>列上的元素为：</p>
</blockquote>
<p><span class="math display">\[
\begin{gathered}
p_{i,2j} =\sin\left(\frac i{10000^{2j/d}}\right), \\
p_{i,2j+1} =\cos\left(\frac i{10000^{2j/d}}\right).
\end{gathered}
\]</span>
这里利用了正弦函数和余弦函数的连续性和周期性，来为每个位置生成一个固定的编码。具体来说，对于每一个位置i（也就是序列中的第i个词元）：</p>
<ul>
<li>我们为它的每一个维度（指该词元对应的词嵌入向量的每一个元素）生成一个位置编码。</li>
<li>如果这个维度是偶数（<span
class="math inline">\(2j\)</span>），那么使用正弦函数生成位置编码</li>
<li>如果这个维度是奇数（<span
class="math inline">\(2j+1\)</span>），那么使用余弦函数生成位置编码。</li>
<li>函数的输入是位置i和维度j，通过这种方法可以为每个位置生成一个唯一的编码。</li>
</ul>
<p>之所以使用正弦函数和余弦函数主要归功于它们的周期性和连续性。周期性是指函数的值会在每个完整的周期内重复。连续性是指在实数范围内，函数的图像是无间断的。</p>
<p><strong>当用于位置编码时，正弦和余弦函数可以非常好地表达出序列中单词的相对位置关系</strong>。</p>
<ul>
<li>相邻的单词位置的差距较小，对应的正弦或余弦值的变化也相近（连续性）</li>
<li>相反，序列中距离较远的单词对应的输入数值差距较大，他们的正弦和余弦值的变化也会相对较大（实际中并不直接使用单一的正弦或余弦函数来表达位置信息，而是使用了一系列不同波长的正弦和余弦函数，使得任意两个位置的编码都是唯一的，即使是在很远的序列位置，也能得到有区别性的编码。）</li>
</ul>
<p>正弦和余弦函数的这些特性<strong>让编码的变化能够反映出单词在序列中位置的改变，这种改变可能是相邻位置的微小变动，也可能是较长距离的较大变动</strong>。这就使得模型可以<strong>捕捉到语言序列中单词之间的相对位置关系</strong>，这对于理解和生成语言非常重要。</p>
<h3 id="transformer">Transformer</h3>
<p>自注意力同时具有<u>并行计算</u>和<u>最短的最大路径长度</u>这两个优势，因此，使用自注意力来设计深度架构很有吸引力。对比之前仍然依赖循环神经网络实现输入表示的自注意力模型，<strong>Transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层。</strong></p>
<h4 id="模型">模型</h4>
<blockquote>
<p>Transformer作为编码器一解码器架构的一个实例，其整体架构图如下图所示。与基于Bahdanau注意力实现的序列到序列的学习相比，Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源(输入)
序列和目标(输出)序列的嵌入(embedding) 表示将加上位置编码 (positional
encoding)，再分别输入到编码器和解码器中。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/ValoraY/blog-imgs/main/img/202401161650780.png"
alt="transformer架构" />
<figcaption aria-hidden="true">transformer架构</figcaption>
</figure>
<ul>
<li><p>Transformer的<strong>编码器</strong>是由多个相同的层叠加而成的，每个层都有两个子层
(子层表示为sublayer)。</p>
<ul>
<li><p>子层一：多头自注意力 (multi-head self-attention) 汇聚层。</p>
<p>该层将输入进行了分组处理，每一组分别通过自注意力机制处理后，多个结果又会合并为一组新的编码输出。这个子层主要负责提取输入中的全局依赖关系。</p></li>
<li><p>子层二：位置前馈网络 (positionwise feed-forward network)层。</p>
<p>该层会对每个输入位置对应的编码进行独立的处理，频繁地学习到输入的非线性表示。</p></li>
<li><p>残差连接 (residual
connection)：这种机制引入了“短路”机制，使得神经网络的每层的输入都能直接影响每层的输出，并传播到更深的层次。这种机制有效地缓解了梯度消失/梯度爆炸问题。</p></li>
<li><p>层规范化 (layer normalization):
这个操作将得到的残差结果进行了规范化处理，以调整它们的值范围，从而提升模型训练的稳定性。</p></li>
</ul></li>
<li><p>Transformer解码器也是由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。</p>
<ul>
<li>除了编码器中描述的两个子层之外，<strong>解码器还在这两个子层之间插入了第三个子层</strong>（通常被隐式地包含在解码器中的“自注意力（Self-Attention）”），称为
<strong>编码器一解码器注意力 (encoder-decoder attention)
层。在<u>编码器—解码器注意力中，查询来自前一个解码器层的输出，而键和值来自整个编码器的输出。</u></strong></li>
<li>解码器的自注意力层使用了一个掩蔽机制，以防止预测位置看到后面的位置，这就保证了解码的自回归性质，使得当前输出仅依赖于产生的前面的输出。<strong><u>在解码器自注意力中，查询、键和值都来自上一个解码器层的输出</u></strong>。</li>
</ul></li>
</ul>
<h4 id="位置前馈网络">位置前馈网络</h4>
<p>这里的"前馈网络"其实只是一个特别普通的多层感知机，而"位置前馈网络"特殊就特殊在这个"位置"，<strong>这个"位置"是指这个"前馈网络"会被独立地应用于输入序列的每一个元素</strong>。也就是说，对于输入序列中的每一个位置，我们都会独立地应用同一个前馈网络。从而实现——将元素对应的原有的词向量<strong>变换为</strong>多层感知机（MLP）处理后的新的词向量。</p>
<p>这一变换的意义是：</p>
<ul>
<li>首先，<u>原有的词向量通常是词的静态表示</u>，在特定上下文中，一个词的含义可能会有所变化。<strong><u>通过这种变换，我们可以得到词在特定上下文中的动态表示</u></strong>，这对于理解和生成上下文相关的句子非常有帮助。</li>
<li>另外，这种变换也是<strong>增加模型复杂性</strong>的一种方式，可以使模型具有更强的表达能力。多层感知机（MLP）可以理解为对输入数据的一种非线性变换，通过多个这样的非线性变换，我们可以得到输入数据的一个更抽象、更复杂的表示。就好像我们看一个物体，可以从不同的角度（即语境）获得关于这个物体的不同信息，这种变化使我们对物体的理解更深入、更全面。</li>
<li><strong>这是一种一对一的映射关系，为每个位置提供了一个密集的变换</strong>。在这一点上，它类似于卷积层，因为卷积层也会对输入数据的每一个位置分别进行映射，不过它的映射函数是依赖于邻域的，而前馈网络则更加简单，它的映射函数仅依赖于那一个位置的数据。</li>
</ul>
<h4 id="残差连接和层规范化">残差连接和层规范化</h4>
<h5 id="残差连接">残差连接</h5>
<blockquote>
<p>残差连接（Residual
Connection）也被称为跳过连接，是一种让前面层的信息能够直接流向后面层的方法。在Transformer中，每一层的输入都会与该层的输出进行元素级别的相加操作，这种操作就构成了一种残差连接。残差连接的主要作用是缓解梯度消失问题，使得深层网络的训练变得更加稳定。当网络深度较大时，前向传播和反向传播都可能会遇到数值不稳定性问题，残差连接可以允许梯度直接反向传播到任何一层。</p>
</blockquote>
<h5 id="层规范化">层规范化</h5>
<blockquote>
<p>层规范化（Layer
Normalization）是一种对神经网络中的隐藏层进行规范化的方法，并且层规范在一个样本内部进行，这意味着对于同一层的每个神经元来说，其规范化的统计量（均值、方差）是相同的。主要有两个作用：一是加速模型收敛速度，稳定模型训练；二是具有一定的正则化效果，避免模型过拟合。在Transformer中，将层规范化应用于残差连接后的结果，有助于网络更好地学习和适应数据集的特性。</p>
</blockquote>
<h4 id="编码器">编码器</h4>
<p>编码器<code>EncoderBlock</code>类包含两个子层：多头自注意力和基于位置的前馈网络，这两个子层都使用了残差连接和紧随的层规范化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key_size, query_size, value_size, num_hiddens,</span></span><br><span class="line"><span class="params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span><br><span class="line"><span class="params">                 dropout, use_bias=<span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderBlock, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 多头自注意力</span></span><br><span class="line">        self.attention = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout,</span><br><span class="line">            use_bias)</span><br><span class="line">        <span class="comment"># 残差连接后进行层规范化</span></span><br><span class="line">        self.addnorm1 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 位置前馈网络</span></span><br><span class="line">        self.ffn = PositionWiseFFN(</span><br><span class="line">            ffn_num_input, ffn_num_hiddens, num_hiddens)</span><br><span class="line">        <span class="comment"># 残差连接后进行层规范化</span></span><br><span class="line">        self.addnorm2 = AddNorm(norm_shape, dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, valid_lens</span>):</span><br><span class="line">        <span class="comment"># 多头自注意力 + 残差连接后进行层规范化</span></span><br><span class="line">        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))</span><br><span class="line">        <span class="comment"># 位置前馈网络 + 残差连接后进行层规范化</span></span><br><span class="line">        <span class="keyword">return</span> self.addnorm2(Y, self.ffn(Y))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddNorm</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, normalized_shape, dropout, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(AddNorm, self).__init__(**kwargs)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.ln = nn.LayerNorm(normalized_shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, Y</span>):</span><br><span class="line">        <span class="keyword">return</span> self.ln(self.dropout(Y) + X)</span><br></pre></td></tr></table></figure>
<h4 id="解码器">解码器</h4>
<p>在解码器<code>DecoderBlock</code>类中实现的每个层包含了三个子层：解码器自注意力、“编码器-解码器”注意力和基于位置的前馈网络。这些子层也都被残差连接和紧随的层规范化围绕。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key_size, query_size, value_size, num_hiddens,</span></span><br><span class="line"><span class="params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span><br><span class="line"><span class="params">                 dropout, i, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderBlock, self).__init__(**kwargs)</span><br><span class="line">        self.i = i</span><br><span class="line">        <span class="comment"># 多头自注意力</span></span><br><span class="line">        self.attention1 = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout)</span><br><span class="line">        <span class="comment"># 残差连接后进行层规范化</span></span><br><span class="line">        self.addnorm1 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 编码器－解码器注意力</span></span><br><span class="line">        self.attention2 = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout)</span><br><span class="line">        <span class="comment"># 残差连接后进行层规范化</span></span><br><span class="line">        self.addnorm2 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 位置前馈网络</span></span><br><span class="line">        self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens,</span><br><span class="line">                                   num_hiddens)</span><br><span class="line">        <span class="comment"># 残差连接后进行层规范化</span></span><br><span class="line">        self.addnorm3 = AddNorm(norm_shape, dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, state</span>):</span><br><span class="line">        enc_outputs, enc_valid_lens = state[<span class="number">0</span>], state[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 训练阶段，输出序列的所有词元都在同一时间处理，</span></span><br><span class="line">        <span class="comment"># 因此state[2][self.i]初始化为None。</span></span><br><span class="line">        <span class="comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span></span><br><span class="line">        <span class="comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span></span><br><span class="line">        <span class="keyword">if</span> state[<span class="number">2</span>][self.i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key_values = X</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key_values = torch.cat((state[<span class="number">2</span>][self.i], X), axis=<span class="number">1</span>)</span><br><span class="line">        state[<span class="number">2</span>][self.i] = key_values</span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            batch_size, num_steps, _ = X.shape</span><br><span class="line">            <span class="comment"># dec_valid_lens的开头:(batch_size,num_steps),</span></span><br><span class="line">            <span class="comment"># 其中每一行是[1,2,...,num_steps]</span></span><br><span class="line">            dec_valid_lens = torch.arange(</span><br><span class="line">                <span class="number">1</span>, num_steps + <span class="number">1</span>, device=X.device).repeat(batch_size, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dec_valid_lens = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 多头自注意力 + 残差连接后进行层规范化</span></span><br><span class="line">        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)</span><br><span class="line">        Y = self.addnorm1(X, X2)</span><br><span class="line">        <span class="comment"># 编码器－解码器注意力 + 残差连接后进行层规范化</span></span><br><span class="line">        <span class="comment"># enc_outputs的开头:(batch_size,num_steps,num_hiddens)</span></span><br><span class="line">        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)</span><br><span class="line">        Z = self.addnorm2(Y, Y2)</span><br><span class="line">        <span class="comment"># 位置前馈网络 + 残差连接后进行层规范化</span></span><br><span class="line">        <span class="keyword">return</span> self.addnorm3(Z, self.ffn(Z)), state</span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<ul>
<li>Transformer是编码器－解码器架构的一个实践，尽管在实际情况中编码器或解码器可以单独使用。</li>
<li>在Transformer中，多头自注意力用于表示输入序列和输出序列，不过解码器必须通过掩蔽机制来保留自回归属性。</li>
<li>Transformer中的残差连接和层规范化是训练非常深度模型的重要工具。</li>
<li>Transformer模型中基于位置的前馈网络使用同一个多层感知机，作用是对所有序列位置的表示进行转换。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 动手学深度学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/12/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="《动手学深度学习2.0》学习笔记（二）">
                  <i class="fa fa-angle-left"></i> 《动手学深度学习2.0》学习笔记（二）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/01/17/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" rel="next" title="《动手学深度学习2.0》学习笔记（四）">
                  《动手学深度学习2.0》学习笔记（四） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
<!--
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">deeprookie</span>
  </div>
-->

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
