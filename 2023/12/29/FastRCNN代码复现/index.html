<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"valoray.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Fast RCNN代码复现 项目源代码下载地址：  Fast-R-CNN-pytorch-master https:&#x2F;&#x2F;www.alipan.com&#x2F;s&#x2F;FqYEYzqCe7k 提取码:ue87 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。">
<meta property="og:type" content="article">
<meta property="og:title" content="FastRCNN代码复现">
<meta property="og:url" content="https://valoray.github.io/2023/12/29/FastRCNN%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/index.html">
<meta property="og:site_name" content="DeepRookie">
<meta property="og:description" content="Fast RCNN代码复现 项目源代码下载地址：  Fast-R-CNN-pytorch-master https:&#x2F;&#x2F;www.alipan.com&#x2F;s&#x2F;FqYEYzqCe7k 提取码:ue87 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ooo.0x0.ooo/2023/12/29/OKYKlq.png">
<meta property="og:image" content="https://ooo.0x0.ooo/2023/12/29/OKYvBc.png">
<meta property="article:published_time" content="2023-12-29T04:06:22.000Z">
<meta property="article:modified_time" content="2024-01-03T07:10:10.754Z">
<meta property="article:author" content="deeprookie">
<meta property="article:tag" content="Fast RCNN">
<meta property="article:tag" content="代码复现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ooo.0x0.ooo/2023/12/29/OKYKlq.png">


<link rel="canonical" href="https://valoray.github.io/2023/12/29/FastRCNN%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://valoray.github.io/2023/12/29/FastRCNN%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/","path":"2023/12/29/FastRCNN代码复现/","title":"FastRCNN代码复现"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>FastRCNN代码复现 | DeepRookie</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">DeepRookie</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">想到，就去做，无非一朝还是一生</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#fast-rcnn%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">Fast RCNN代码复现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96coco%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">初始化COCO数据集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E8%AE%AD%E7%BB%83%E9%9B%86%E5%92%8C%E9%AA%8C%E8%AF%81%E9%9B%86"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">构造训练集和验证集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEroi-pooling%E6%A8%A1%E5%9D%97%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">设置ROI
Pooling模块、特征提取网络模型及多目标损失函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">训练网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="deeprookie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">deeprookie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ValoraY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ValoraY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1432843916@qq.com" title="E-Mail → mailto:1432843916@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/m0_51619560/category_12535222.html" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51619560&#x2F;category_12535222.html" rel="noopener me" target="_blank">CSDN</a>
      </span>
  </div>

    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/2024/01/18/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（五）" target="_blank">《动手学深度学习2.0》学习笔记（五）</a>
          </li>
        
          <li>
            <a href="/2024/01/17/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（四）" target="_blank">《动手学深度学习2.0》学习笔记（四）</a>
          </li>
        
          <li>
            <a href="/2024/01/16/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（三）" target="_blank">《动手学深度学习2.0》学习笔记（三）</a>
          </li>
        
          <li>
            <a href="/2024/01/12/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（二）" target="_blank">《动手学深度学习2.0》学习笔记（二）</a>
          </li>
        
          <li>
            <a href="/2024/01/11/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02-0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="《动手学深度学习2.0》学习笔记（一）" target="_blank">《动手学深度学习2.0》学习笔记（一）</a>
          </li>
        
      </ul>
    </div>


        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://valoray.github.io/2023/12/29/FastRCNN%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="deeprookie">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DeepRookie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="FastRCNN代码复现 | DeepRookie">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FastRCNN代码复现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-29 12:06:22" itemprop="dateCreated datePublished" datetime="2023-12-29T12:06:22+08:00">2023-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-03 15:10:10" itemprop="dateModified" datetime="2024-01-03T15:10:10+08:00">2024-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">目标检测</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="fast-rcnn代码复现">Fast RCNN代码复现</h1>
<p>项目源代码下载地址：</p>
<blockquote>
<p>Fast-R-CNN-pytorch-master https://www.alipan.com/s/FqYEYzqCe7k
提取码:ue87 点击链接保存，或者复制本段内容，打开「阿里云盘」APP
，无需下载极速在线查看，视频原画倍速播放。</p>
</blockquote>
<span id="more"></span>
<p>项目目录如下;</p>
<figure>
<img src="https://ooo.0x0.ooo/2023/12/29/OKYKlq.png" alt="OKYKlq.png" />
<figcaption aria-hidden="true">OKYKlq.png</figcaption>
</figure>
<p>对Fast RCNN的论文理解见专栏的上篇内容，本文介绍Fast
RCNN的代码复现。基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">利用coco2017数据集训练Fast-RCNN模型（训练过程详细步骤记录）：</span><br><span class="line"></span><br><span class="line">（1）初始化COCO数据集</span><br><span class="line"></span><br><span class="line">（2）构造训练集和验证集：利用选择搜索算法（selective-search）生成一定数量的候选框，将候选框与gound-truth进行IOU（交并比）计算，如果IoU大于等于0.5，则认为候选区域是正样本，0.1&lt;IoU&lt;0.5，则认为候选区域是负样本</span><br><span class="line"></span><br><span class="line">（3）设置ROI Pooling模块、特征提取网络模型。利用ROIPlooing方法，从共享特征图抠出各个候选区域特征图</span><br><span class="line"></span><br><span class="line">（4）设置输出为一个分类分支（类别类数+背景类（1））与回归分支</span><br><span class="line"></span><br><span class="line">（5）设置多目标损失函数：交叉熵损失与回归损失</span><br><span class="line"></span><br><span class="line">（6）训练网络模型</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="初始化coco数据集">初始化COCO数据集</h4>
<p><strong>COCOdataset.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    COCO数据集的处理</span></span><br><span class="line"><span class="string">    1、读取数据</span></span><br><span class="line"><span class="string">    2、数据的预处理</span></span><br><span class="line"><span class="string">    3、数据的加载</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	需要修改内容：COCO数据集的存放路径、加载训练集还是验证集(mode为&quot;train&quot;or&quot;val&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">COCOdataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="comment"># todo：注意修改coco数据集的存放路径</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">dir</span>=<span class="string">&#x27;D:\\WritePapers\\object_detection_basics\\Datasets\\COCO2017\\&#x27;</span>, mode=<span class="string">&#x27;train&#x27;</span>,</span></span><br><span class="line"><span class="params">                 transform=transforms.Compose(<span class="params">[transforms.ToTensor(<span class="params"></span>),</span></span></span><br><span class="line"><span class="params"><span class="params">                                               transforms.Normalize(<span class="params">[<span class="number">0.485</span>, <span class="number">0.456</span>, -<span class="number">.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span>)]</span>)</span>):</span><br><span class="line">        <span class="comment"># transform执行2步操作：1、将PIL.Image转换为torch.Tensor，并自动将数据缩放到[0,1]之间；</span></span><br><span class="line">        <span class="comment"># 2.对图像进行标准化。这里的两个参数分别是RGB通道的均值和标准差。这个操作会按照每个通道进行标准化，即(image - mean) / std</span></span><br><span class="line">        <span class="comment"># transforms.Normalize([0.485, 0.456, -.406], [0.229, 0.224, 0.225])的两个参数分别是ImageNet数据集的统计得到的RGB通道的均值和标准差</span></span><br><span class="line">        <span class="comment"># 这样做的目的是使得模型的输入数据分布和预训练模型（项目使用了在ImageNet预训练的VGG19模型）的输入数据分布一致，从而可以更好地利用预训练模型。</span></span><br><span class="line">        <span class="keyword">assert</span> mode <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>], <span class="string">&#x27;mode must be \&#x27;train\&#x27; or \&#x27;val\&#x27;&#x27;</span></span><br><span class="line">        self.<span class="built_in">dir</span> = <span class="built_in">dir</span> <span class="comment"># self关键字代表类的实例</span></span><br><span class="line">        self.mode = mode <span class="comment"># train则加载训练集，val则加载验证集</span></span><br><span class="line">        self.transform = transform</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(self.<span class="built_in">dir</span>, <span class="string">&#x27;%s.json&#x27;</span> % self.mode), <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f: <span class="comment">#%s是一个字符串占位符。%操作符用于指定要插入的值==&gt;%s会被self.mode的值替换</span></span><br><span class="line">            self.ss_regions = json.load(f)</span><br><span class="line">        <span class="comment"># with语句并不创建一个新的作用域。在with语句块内部定义的变量，其作用域是包含with语句的那个作用域。</span></span><br><span class="line">        self.img_dir = os.path.join(self.<span class="built_in">dir</span>, <span class="string">&#x27;%s2017&#x27;</span> % self.mode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.ss_regions) <span class="comment"># 说明ss_regions是一个列表，每个元素代表一张图片对应的region信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i, max_num_pos=<span class="number">8</span>, max_num_neg=<span class="number">16</span></span>):</span><br><span class="line">        img = PIL.Image.<span class="built_in">open</span>(os.path.join(self.img_dir, <span class="string">&#x27;%012d.jpg&#x27;</span> %</span><br><span class="line">                                     self.ss_regions[i][<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">        <span class="comment"># %012d是一个占位符，表示一个十二位的整数，不足十二位的部分会用0填充==&gt;%012d会被self.ss_regions[i][&#x27;id&#x27;]的值替换，self.ss_regions[i][&#x27;id&#x27;]是从JSON文件中读取的某张图片的ID</span></span><br><span class="line">        img = img.convert(<span class="string">&#x27;RGB&#x27;</span>) <span class="comment"># 将图片转换为RGB格式</span></span><br><span class="line">        img = img.resize([<span class="number">224</span>, <span class="number">224</span>])</span><br><span class="line">        pos_regions = self.ss_regions[i][<span class="string">&#x27;pos_regions&#x27;</span>] <span class="comment"># 获取正样本区域</span></span><br><span class="line">        neg_regions = self.ss_regions[i][<span class="string">&#x27;neg_regions&#x27;</span>] <span class="comment"># 获取负样本区域</span></span><br><span class="line">        <span class="keyword">if</span> self.transform != <span class="literal">None</span>: <span class="comment"># 如果设置了图像预处理方法</span></span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pos_regions) &gt; max_num_pos: <span class="comment"># 如果正样本区域的数量大于最大数量,随机选择一部分正样本区域</span></span><br><span class="line">            pos_regions = random.sample(pos_regions, max_num_pos)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(neg_regions) &gt; max_num_neg:</span><br><span class="line">            neg_regions = random.sample(neg_regions, max_num_neg)</span><br><span class="line">        regions = pos_regions + neg_regions <span class="comment"># 合并正样本区域和负样本区域</span></span><br><span class="line">        random.shuffle(regions) <span class="comment"># 随机打乱区域</span></span><br><span class="line">        rects = [] <span class="comment"># 初始化矩形列表</span></span><br><span class="line">        rela_locs = []  <span class="comment"># 初始化相对位置列表</span></span><br><span class="line">        cats = [] <span class="comment"># 初始化类别列表</span></span><br><span class="line">        <span class="keyword">for</span> region <span class="keyword">in</span> regions:<span class="comment"># 遍历第i张图片的得到的区域（包括正样本和负样本区域）</span></span><br><span class="line">            rects.append(region[<span class="string">&#x27;rect&#x27;</span>]) <span class="comment"># 将区域的矩形信息添加到矩形列表中</span></span><br><span class="line">            p_rect = region[<span class="string">&#x27;rect&#x27;</span>] <span class="comment"># 获取区域的矩形信息</span></span><br><span class="line">            g_rect = region[<span class="string">&#x27;gt_rect&#x27;</span>] <span class="comment"># 获取区域的真实矩形信息</span></span><br><span class="line">            t_x = (g_rect[<span class="number">0</span>] + g_rect[<span class="number">2</span>] - p_rect[<span class="number">0</span>] - p_rect[<span class="number">2</span>]) / <span class="number">2</span> / (p_rect[<span class="number">2</span>] - p_rect[<span class="number">0</span>])</span><br><span class="line">            t_y = (g_rect[<span class="number">1</span>] + g_rect[<span class="number">3</span>] - p_rect[<span class="number">1</span>] - p_rect[<span class="number">3</span>]) / <span class="number">2</span> / (p_rect[<span class="number">3</span>] - p_rect[<span class="number">1</span>])</span><br><span class="line">            t_w = math.log((g_rect[<span class="number">2</span>] - g_rect[<span class="number">0</span>]) / (p_rect[<span class="number">2</span>] - p_rect[<span class="number">0</span>]))</span><br><span class="line">            t_h = math.log((g_rect[<span class="number">3</span>] - g_rect[<span class="number">1</span>]) / (p_rect[<span class="number">3</span>] - p_rect[<span class="number">1</span>]))</span><br><span class="line">            rela_locs.append([t_x, t_y, t_w, t_h]) <span class="comment"># 将区域的相对位置信息添加到相对位置列表中</span></span><br><span class="line">            cats.append(region[<span class="string">&#x27;category&#x27;</span>]) <span class="comment"># 将区域的类别信息添加到类别列表中</span></span><br><span class="line">        roi_idx_len = <span class="built_in">len</span>(regions) <span class="comment"># 获取区域的数量</span></span><br><span class="line">        <span class="keyword">return</span> img, rects, roi_idx_len, rela_locs, cats</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset = COCOdataset()</span></span><br><span class="line"><span class="comment"># print(dataset[1][0].shape)</span></span><br><span class="line"><span class="comment"># print(dataset[1][1])</span></span><br><span class="line"><span class="comment"># from torch.utils.data import DataLoader</span></span><br><span class="line"><span class="comment"># dataloader = DataLoader(dataset, batch_size=2)</span></span><br><span class="line"><span class="comment"># print(next(iter(dataloader))[1])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dataset = COCOdataset()</span><br><span class="line">    <span class="built_in">print</span>(dataset.__len__())</span><br><span class="line">    img, rects, roi_idx_len, rela_locs, cats = dataset.__getitem__(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(img, rects, roi_idx_len, rela_locs, cats)</span><br><span class="line">    <span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">    loader = DataLoader(dataset, batch_size=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(loader):</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="构造训练集和验证集">构造训练集和验证集</h4>
<p><strong>利用选择搜索算法（selective-search）生成一定数量的候选框，将候选框与gound-truth进行IOU（交并比）计算，如果IoU大于等于0.5，则认为候选区域是正样本，0.1&lt;IoU&lt;0.5，则认为候选区域是负样本</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse <span class="comment"># 导入argparse模块，用于处理命令行参数</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># 导入sys模块，用于处理Python运行时环境</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> progressbar <span class="keyword">import</span> * <span class="comment"># 导入progressbar模块，用于显示进度条</span></span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO <span class="comment"># 导入pycocotools模块，用于处理COCO数据集</span></span><br><span class="line"><span class="keyword">from</span> selectivesearch <span class="keyword">import</span> selective_search <span class="comment"># 从selectivesearch模块导入selective_search函数，用于进行选择性搜索</span></span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, util, color <span class="comment"># 从selectivesearch模块导入selective_search函数，用于进行选择性搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_iou</span>(<span class="params">a, b</span>): <span class="comment"># 定义计算IoU（交并比）的函数，输入参数为两个矩形框</span></span><br><span class="line">    <span class="comment"># 矩形框的格式为：[左上角x坐标，左上角y坐标，宽度，高度]</span></span><br><span class="line">    a_min_x, a_min_y, a_delta_x, a_delta_y = a</span><br><span class="line">    b_min_x, b_min_y, b_delta_x, b_delta_y = b</span><br><span class="line">    a_max_x = a_min_x + a_delta_x</span><br><span class="line">    a_max_y = a_min_y + a_delta_y</span><br><span class="line">    b_max_x = b_min_x + b_delta_x</span><br><span class="line">    b_max_y = b_min_y + b_delta_y</span><br><span class="line">    <span class="comment"># 如果两个矩形框没有交集，则IoU为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span>(a_max_y, b_max_y) &lt; <span class="built_in">max</span>(a_min_y, b_min_y) <span class="keyword">or</span> <span class="built_in">min</span>(a_max_x, b_max_x) &lt; <span class="built_in">max</span>(a_min_x, b_min_x):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 计算交集的面积</span></span><br><span class="line">        intersect_area = (<span class="built_in">min</span>(a_max_y, b_max_y) - <span class="built_in">max</span>(a_min_y, b_min_y) + <span class="number">1</span>) * \</span><br><span class="line">            (<span class="built_in">min</span>(a_max_x, b_max_x) - <span class="built_in">max</span>(a_min_x, b_min_x) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 计算并集的面积</span></span><br><span class="line">        union_area = (a_delta_x + <span class="number">1</span>) * (a_delta_y + <span class="number">1</span>) + \</span><br><span class="line">            (b_delta_x + <span class="number">1</span>) * (b_delta_y + <span class="number">1</span>) - intersect_area</span><br><span class="line">        <span class="comment"># 返回IoU</span></span><br><span class="line">        <span class="keyword">return</span> intersect_area / union_area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ss_img</span>(<span class="params">img_id, coco, cat_dict, args</span>): <span class="comment"># 定义selective_search函数，输入参数为图像id、COCO数据集、类别字典、命令行参数</span></span><br><span class="line">    img_path = os.path.join(args.data_dir, args.mode +</span><br><span class="line">                            <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;%012d.jpg&#x27;</span> % img_id) <span class="comment"># 获取图像的路径</span></span><br><span class="line">    coco_dict = &#123;cat[<span class="string">&#x27;id&#x27;</span>]: cat[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">                 <span class="keyword">for</span> cat <span class="keyword">in</span> coco.loadCats(coco.getCatIds())&#125;  <span class="comment"># 创建一个字典，将COCO数据集的类别ID映射到类别名</span></span><br><span class="line">    img = io.imread(img_path) <span class="comment"># 读取图像</span></span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">2</span>:    <span class="comment"># 如果图像是灰度图，则将其转换为RGB图像</span></span><br><span class="line">        img = color.gray2rgb(img)</span><br><span class="line">    _, ss_regions = selective_search(   <span class="comment"># 对图像进行选择性搜索，获取候选区域</span></span><br><span class="line">        img, args.scale, args.sigma, args.min_size)         <span class="comment"># &#x27;rect&#x27;: (left, top, width, height)</span></span><br><span class="line">    anns = coco.loadAnns(coco.getAnnIds(</span><br><span class="line">        imgIds=[img_id], catIds=coco.getCatIds(catNms=args.cats))) <span class="comment"># 获取图像的标注信息</span></span><br><span class="line">    pos_regions = [] <span class="comment"># 初始化正样本区域列表</span></span><br><span class="line">    neg_regions = [] <span class="comment"># 初始化负样本区域列表</span></span><br><span class="line">    h = img.shape[<span class="number">0</span>] <span class="comment"># 获取图像的高度</span></span><br><span class="line">    w = img.shape[<span class="number">1</span>] <span class="comment"># 获取图像的宽度</span></span><br><span class="line">    <span class="keyword">for</span> region <span class="keyword">in</span> ss_regions: <span class="comment"># 遍历每个候选区域</span></span><br><span class="line">        <span class="keyword">for</span> ann <span class="keyword">in</span> anns: <span class="comment"># 遍历每个标注信息</span></span><br><span class="line">            iou = cal_iou(region[<span class="string">&#x27;rect&#x27;</span>], ann[<span class="string">&#x27;bbox&#x27;</span>]) <span class="comment"># 计算候选区域和标注区域的IoU</span></span><br><span class="line">            <span class="keyword">if</span> iou &gt;= <span class="number">0.1</span>: <span class="comment"># 如果IoU大于等于0.1，则认为候选区域是有效的</span></span><br><span class="line">                rect = <span class="built_in">list</span>(region[<span class="string">&#x27;rect&#x27;</span>]) <span class="comment"># 获取候选区域的矩形框</span></span><br><span class="line">                rect[<span class="number">0</span>] = rect[<span class="number">0</span>] / w <span class="comment"># 将矩形框的x坐标转换为相对于图像宽度的比例</span></span><br><span class="line">                rect[<span class="number">1</span>] = rect[<span class="number">1</span>] / h <span class="comment"># 将矩形框的y坐标转换为相对于图像高度的比例</span></span><br><span class="line">                rect[<span class="number">2</span>] = rect[<span class="number">0</span>] + rect[<span class="number">2</span>] / w <span class="comment"># 将矩形框的宽度转换为相对于图像宽度的比例</span></span><br><span class="line">                rect[<span class="number">3</span>] = rect[<span class="number">1</span>] + rect[<span class="number">3</span>] / h <span class="comment"># 将矩形框的高度转换为相对于图像高度的比例</span></span><br><span class="line">                gt_rect = <span class="built_in">list</span>(ann[<span class="string">&#x27;bbox&#x27;</span>]) <span class="comment"># 获取标注区域的矩形框</span></span><br><span class="line">                gt_rect[<span class="number">0</span>] = gt_rect[<span class="number">0</span>] / w <span class="comment"># 将矩形框的x坐标转换为相对于图像宽度的比例</span></span><br><span class="line">                gt_rect[<span class="number">1</span>] = gt_rect[<span class="number">1</span>] / h <span class="comment"># 将矩形框的y坐标转换为相对于图像高度的比例</span></span><br><span class="line">                gt_rect[<span class="number">2</span>] = gt_rect[<span class="number">0</span>] + gt_rect[<span class="number">2</span>] / w <span class="comment"># 将矩形框的宽度转换为相对于图像宽度的比例</span></span><br><span class="line">                gt_rect[<span class="number">3</span>] = gt_rect[<span class="number">1</span>] + gt_rect[<span class="number">3</span>] / h <span class="comment"># 将矩形框的高度转换为相对于图像高度的比例</span></span><br><span class="line">                <span class="keyword">if</span> iou &gt;= <span class="number">0.5</span>: <span class="comment"># 如果IoU大于等于0.5，则认为候选区域是正样本</span></span><br><span class="line">                    pos_regions.append(&#123;<span class="string">&#x27;rect&#x27;</span>: rect, </span><br><span class="line">                                        <span class="string">&#x27;gt_rect&#x27;</span>: gt_rect,</span><br><span class="line">                                        <span class="string">&#x27;category&#x27;</span>: cat_dict[coco_dict[ann[<span class="string">&#x27;category_id&#x27;</span>]]]&#125;)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 否则，认为候选区域是负样本</span></span><br><span class="line">                    neg_regions.append(&#123;<span class="string">&#x27;rect&#x27;</span>: rect, </span><br><span class="line">                                        <span class="string">&#x27;gt_rect&#x27;</span>: gt_rect,</span><br><span class="line">                                        <span class="string">&#x27;category&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> pos_regions, neg_regions <span class="comment"># 返回正样本区域和负样本区域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&#x27;parser to create regions&#x27;</span>) <span class="comment"># 创建一个命令行参数解析器，用于处理命令行参数。</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--data_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;D:\\WritePapers\\object_detection_basics\\Datasets\\COCO2017\\&#x27;</span>) <span class="comment"># 指定COCO2017数据集的路径</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--mode&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;train&#x27;</span>)   <span class="comment"># train/val</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;D:\\WritePapers\\object_detection_basics\\Datasets\\COCO2017\\&#x27;</span>) <span class="comment">#指定保存结果的路径</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cats&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, nargs=<span class="string">&#x27;*&#x27;</span>, default=[</span><br><span class="line">                        <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>]) <span class="comment"># 指定需要处理的类别</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--scale&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">30.0</span>) <span class="comment"># 指定选择性搜索的尺度</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--sigma&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.8</span>) <span class="comment"># 指定选择性搜索的高斯平滑参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--min_size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">50</span>) <span class="comment"># 指定选择性搜索的最小区域大小</span></span><br><span class="line">    args = parser.parse_args() <span class="comment"># 解析命令行参数，并将结果保存在args中</span></span><br><span class="line">    coco = COCO(os.path.join(args.data_dir, <span class="string">&#x27;annotations&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;instances_%s2017.json&#x27;</span> % args.mode)) <span class="comment">#加载COCO2017数据集的标注信息</span></span><br><span class="line">    cat_dict = &#123;args.cats[i]: i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(args.cats))&#125; <span class="comment"># 创建一个字典，将类别名称映射到类别ID</span></span><br><span class="line">    cat_dict[<span class="string">&#x27;background&#x27;</span>] = <span class="number">0</span> <span class="comment"># 将背景类别的ID设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get relavant image ids</span></span><br><span class="line">    <span class="keyword">if</span> args.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">        num_cat = <span class="number">400</span> <span class="comment"># 如果运行模式为训练，则每个类别的图像数量设置为400</span></span><br><span class="line">    <span class="keyword">if</span> args.mode == <span class="string">&#x27;val&#x27;</span>:</span><br><span class="line">        num_cat = <span class="number">100</span> <span class="comment"># 如果运行模式为验证，则每个类别的图像数量设置为100</span></span><br><span class="line">    img_ids = []</span><br><span class="line">    cat_ids = coco.getCatIds(catNms=args.cats) <span class="comment"># 获取需要处理的类别的ID</span></span><br><span class="line">    <span class="keyword">for</span> cat_id <span class="keyword">in</span> cat_ids:</span><br><span class="line">        cat_img_ids = coco.getImgIds(catIds=[cat_id]) <span class="comment"># 获取该类别的所有图像ID</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cat_img_ids) &gt; num_cat:</span><br><span class="line">            cat_img_ids = random.sample(cat_img_ids, num_cat) <span class="comment"># 如果该类别的图像数量大于num_cat，则随机选择num_cat个图像</span></span><br><span class="line">        img_ids += cat_img_ids <span class="comment"># 将选择的图像ID添加到图像ID列表</span></span><br><span class="line">    img_ids = <span class="built_in">list</span>(<span class="built_in">set</span>(img_ids)) <span class="comment"># 去除重复的图像ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># selective_search each image</span></span><br><span class="line">    <span class="comment"># [&#123;&#x27;id&#x27;: 1, &#x27;pos_regions&#x27;:[...], &#x27;neg_regions&#x27;:[...]&#125;, ...]</span></span><br><span class="line"></span><br><span class="line">    num_imgs = <span class="built_in">len</span>(img_ids) <span class="comment"># 获取图像的数量</span></span><br><span class="line">    ss_regions = [] <span class="comment"># 初始化选择性搜索的区域列表</span></span><br><span class="line">    p = ProgressBar(widgets=[<span class="string">&#x27;Progress: &#x27;</span>, Percentage(),</span><br><span class="line">                             <span class="string">&#x27; &#x27;</span>, Bar(<span class="string">&#x27;#&#x27;</span>), <span class="string">&#x27; &#x27;</span>, Timer(), <span class="string">&#x27; &#x27;</span>, ETA()]) <span class="comment"># 创建一个进度条</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> p(<span class="built_in">range</span>(num_imgs)): <span class="comment"># 遍历每个图像</span></span><br><span class="line">        img_id = img_ids[i] <span class="comment"># 获取当前图像的ID</span></span><br><span class="line">        pos_regions, neg_regions = ss_img(img_id, coco, cat_dict, args) <span class="comment"># 对当前图像进行选择性搜索，获取正样本区域和负样本区域</span></span><br><span class="line">        ss_regions.append(&#123;<span class="string">&#x27;id&#x27;</span>: img_id,</span><br><span class="line">                           <span class="string">&#x27;pos_regions&#x27;</span>: pos_regions,</span><br><span class="line">                           <span class="string">&#x27;neg_regions&#x27;</span>: neg_regions&#125;)<span class="comment"># 将当前图像的ID、正样本区域和负样本区域添加到选择性搜索的区域列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># save</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(args.save_dir, <span class="string">&#x27;%s.json&#x27;</span> % args.mode), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(ss_regions, f) <span class="comment"># 将选择性搜索的区域列表保存为JSON格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="设置roi-pooling模块特征提取网络模型及多目标损失函数">设置ROI
Pooling模块、特征提取网络模型及多目标损失函数</h4>
<p><strong>ROI Plooing模块</strong> <strong>roipooling.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ROIPooling</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, output_size</span>): <span class="comment"># 初始化函数，设置输出大小</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.maxpool = nn.AdaptiveMaxPool2d(output_size)  <span class="comment"># 创建一个自适应最大池化层，输出大小为output_size</span></span><br><span class="line">        self.size = output_size  <span class="comment"># 设置输出大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, imgs, rois, roi_idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param img: img:批次内的图像</span></span><br><span class="line"><span class="string">        :param rois: rois:[[单张图片内框体],[],[]]</span></span><br><span class="line"><span class="string">        :param roi_idx: [2]*6-------&gt;[2, 2, 2, 2, 2, 2]</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = rois.shape[<span class="number">0</span>] <span class="comment"># 获取roi的数量</span></span><br><span class="line">        h = imgs.shape[<span class="number">2</span>] <span class="comment"># 获取图像的高度</span></span><br><span class="line">        w = imgs.shape[<span class="number">3</span>] <span class="comment"># 获取图像的宽度</span></span><br><span class="line"></span><br><span class="line">        x1 = rois[:, <span class="number">0</span>] <span class="comment"># 获取所有区域的左上角x坐标</span></span><br><span class="line">        y1 = rois[:, <span class="number">1</span>] <span class="comment"># 获取所有区域的左上角y坐标</span></span><br><span class="line">        x2 = rois[:, <span class="number">2</span>] <span class="comment"># 获取所有区域的右下角x坐标</span></span><br><span class="line">        y2 = rois[:, <span class="number">3</span>] <span class="comment"># 获取所有区域的右下角y坐标</span></span><br><span class="line"></span><br><span class="line">        x1 = np.floor(x1 * w).astype(<span class="built_in">int</span>) <span class="comment"># 将x1坐标转换为图像的实际坐标</span></span><br><span class="line">        x2 = np.ceil(x2 * w).astype(<span class="built_in">int</span>) <span class="comment"># 将x2坐标转换为图像的实际坐标</span></span><br><span class="line">        y1 = np.floor(y1 * h).astype(<span class="built_in">int</span>) <span class="comment"># 将y1坐标转换为图像的实际坐标</span></span><br><span class="line">        y2 = np.ceil(y2 * h).astype(<span class="built_in">int</span>) <span class="comment"># 将y2坐标转换为图像的实际坐标</span></span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment"># 初始化结果列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 遍历每个区域</span></span><br><span class="line">            img = imgs[roi_idx[i]].unsqueeze(dim=<span class="number">0</span>) <span class="comment"># 获取第i个区域所在的图像</span></span><br><span class="line">            img = img[:, :, y1[i]:y2[i], x1[i]:x2[i]]  <span class="comment"># 对图像进行裁剪，只保留区域内的部分</span></span><br><span class="line">            img = self.maxpool(img) <span class="comment"># 对裁剪后的图像进行最大池化操作</span></span><br><span class="line">            res.append(img) <span class="comment"># 将处理后的图像添加到结果列表中</span></span><br><span class="line">        res = torch.cat(res, dim=<span class="number">0</span>) <span class="comment"># 将所有处理后的图像沿着批次维度拼接起来，最终res保存了所有池化后的ROI区域</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    imgs = torch.randn(<span class="number">2</span>, <span class="number">10</span>, <span class="number">224</span>, <span class="number">224</span>) <span class="comment"># 创建一个随机的图像张量（batch_size, Channel, Height, Weight）</span></span><br><span class="line">    rois = np.array([[<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.4</span>],</span><br><span class="line">                    [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.7</span>],</span><br><span class="line">                    [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>]]) <span class="comment"># 创建一个随机的区域张量（x1, y1, x2, y2）</span></span><br><span class="line">    <span class="comment"># roi_idx表示每个区域（Region of Interest，ROI）所在的图像的索引</span></span><br><span class="line">    <span class="comment"># 表示有三个区域，前两个区域在第一张图像上（索引为0），第三个区域在第二张图像上（索引为1）</span></span><br><span class="line">    roi_idx = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    r = ROIPooling((<span class="number">7</span>, <span class="number">7</span>)) <span class="comment"># (7, 7)表示池化后的输出大小为7x7。这意味着无论输入区域的大小如何，ROIPooling层都会将其池化为7x7的大小</span></span><br><span class="line">    <span class="built_in">print</span>(r.forward(imgs, rois, roi_idx).shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>fast_rcnn.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .roipooling <span class="keyword">import</span> ROIPooling <span class="comment"># 从当前目录下的roipooling模块导入ROIPooling类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastRCNN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes</span>):<span class="comment"># 初始化方法，接收一个参数：类别数量</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.num_classes = num_classes <span class="comment"># 将类别数量保存为实例变量</span></span><br><span class="line">        vgg = torchvision.models.vgg19_bn(pretrained=<span class="literal">True</span>) <span class="comment"># 加载预训练的VGG19模型</span></span><br><span class="line">        <span class="comment"># 获取VGG19模型的特征提取部分：通过卷积和池化操作提取图像的特征</span></span><br><span class="line">        <span class="comment"># vgg.features.children(): vgg.features获取VGG19模型的特征提取部分，children()方法获取这部分的所有子模块。这些子模块是一系列的卷积层、激活函数和池化层。</span></span><br><span class="line">        <span class="comment"># list(vgg.features.children()): 将子模块的迭代器转换为列表</span></span><br><span class="line">        <span class="comment"># list(vgg.features.children())[:-1]: 使用切片操作获取除最后一个子模块外的所有子模块。在VGG19模型中，最后一个子模块是一个池化层。</span></span><br><span class="line">        <span class="comment"># *list(vgg.features.children())[:-1]: 使用*操作符将列表解包，这样每个子模块都会作为nn.Sequential的一个单独参数传入。</span></span><br><span class="line">        <span class="comment"># nn.Sequential(*list(vgg.features.children())[:-1]): nn.Sequential是一个容器，它按照在构造函数中传入的顺序保存各个模块。</span></span><br><span class="line">        self.features = nn.Sequential(*<span class="built_in">list</span>(vgg.features.children())[:-<span class="number">1</span>])</span><br><span class="line">        self.roipool = ROIPooling(output_size=(<span class="number">7</span>, <span class="number">7</span>)) <span class="comment"># 创建ROIPooling层，输出大小为7x7</span></span><br><span class="line">        <span class="comment"># vgg.classifier.children(): vgg.classifier获取VGG19模型的分类部分，children()方法获取这部分的所有子模块。这些子模块是一系列的全连接层、激活函数和Dropout层。</span></span><br><span class="line">        <span class="comment"># list(vgg.classifier.children())[:-1]: 使用切片操作获取除最后一个子模块外的所有子模块。在VGG19模型中，最后一个子模块是一个全连接层，用于输出每个类别的概率。</span></span><br><span class="line">        self.output = nn.Sequential(*<span class="built_in">list</span>(vgg.classifier.children())[:-<span class="number">1</span>]) <span class="comment"># 获取VGG19模型的分类部分</span></span><br><span class="line">        self.prob = nn.Linear(<span class="number">4096</span>, num_classes+<span class="number">1</span>)<span class="comment"># 创建一个线性层，用于输出每个类别的概率</span></span><br><span class="line">        self.loc = nn.Linear(<span class="number">4096</span>, <span class="number">4</span> * (num_classes + <span class="number">1</span>)) <span class="comment"># 创建一个线性层，用于输出每个类别的边界框位置</span></span><br><span class="line"></span><br><span class="line">        self.cat_loss = nn.CrossEntropyLoss() <span class="comment"># 创建交叉熵损失函数，用于计算类别损失</span></span><br><span class="line">        self.loc_loss = nn.SmoothL1Loss() <span class="comment"># 创建Smooth L1损失函数，用于计算位置损失</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img, rois, roi_idx</span>): <span class="comment"># 接收三个参数：图像、区域、区域索引</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param img: img:批次内的图像</span></span><br><span class="line"><span class="string">        :param rois: rois:[[单张图片内框体],[],[]]</span></span><br><span class="line"><span class="string">        :param roi_idx: [2]*6-------&gt;[2, 2, 2, 2, 2, 2]</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = self.features(img) <span class="comment"># 对图像进行特征提取</span></span><br><span class="line">        res = self.roipool(res, rois, roi_idx) <span class="comment"># 对特征图进行ROIPooling</span></span><br><span class="line">        res = res.view(res.shape[<span class="number">0</span>], -<span class="number">1</span>) <span class="comment"># 将ROIPooling的结果展平</span></span><br><span class="line">        features = self.output(res) <span class="comment"># 对展平的结果进行分类</span></span><br><span class="line">        prob = self.prob(features) <span class="comment"># 计算每个类别的概率</span></span><br><span class="line">        loc = self.loc(features).view(-<span class="number">1</span>, self.num_classes+<span class="number">1</span>, <span class="number">4</span>) <span class="comment"># 计算每个类别的边界框位置</span></span><br><span class="line">        <span class="comment"># 输出的张量的形状就变成了(N, num_classes + 1, 4)，其中N是批次大小，num_classes + 1是类别数量（包括背景类别），4是边界框的参数数量。</span></span><br><span class="line">        <span class="comment"># 相当于最终输出是==&gt;每个图像都会输出：每个类别对应的一个边界框，这个边界框由4个参数确定。</span></span><br><span class="line">        <span class="keyword">return</span> prob, loc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, prob, bbox, label, gt_bbox, lmb=<span class="number">1.0</span></span>): <span class="comment"># 计算损失的方法，接收五个参数：预测类别概率、预测边界框、真实类别标签、真实边界框、lambda</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param prob: 预测类别</span></span><br><span class="line"><span class="string">        :param bbox:预测边界框</span></span><br><span class="line"><span class="string">        :param label:真实类别</span></span><br><span class="line"><span class="string">        :param gt_bbox:真实边界框</span></span><br><span class="line"><span class="string">        :param lmb:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        loss_cat = self.cat_loss(prob, label) <span class="comment"># 计算类别损失</span></span><br><span class="line">        lbl = label.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).expand(label.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">4</span>) <span class="comment"># 将标签扩展为与边界框相同的形状 (N, 1, 4)，N：标签的数量 1：每个标签对应一个边界框 4：边界框的参数数量</span></span><br><span class="line">        mask = (label != <span class="number">0</span>).<span class="built_in">float</span>().view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>).expand(label.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">4</span>) <span class="comment"># 将标签扩展为与边界框相同的形状</span></span><br><span class="line">        loss_loc = self.loc_loss(gt_bbox * mask, bbox.gather(<span class="number">1</span>, lbl).squeeze(<span class="number">1</span>) * mask) <span class="comment"># 计算位置损失</span></span><br><span class="line">        loss = loss_cat + lmb * loss_loc <span class="comment"># 计算总损失</span></span><br><span class="line">        <span class="keyword">return</span> loss, loss_cat, loss_loc <span class="comment"># 返回总损失、类别损失和位置损失</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="训练网络模型">训练网络模型</h4>
<p><strong>train.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse <span class="comment"># 导入argparse模块，用于处理命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataset <span class="keyword">import</span> COCOdataset</span><br><span class="line"><span class="keyword">from</span> fast_rcnn <span class="keyword">import</span> FastRCNN</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练函数，输入参数为模型、训练数据集、优化器和命令行参数</span></span><br><span class="line"><span class="comment"># 训练时要用gpu，记得把参数--cuda的默认值改为True</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, train_dataset, optimizer, args</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    num_batches = <span class="built_in">len</span>(train_dataset) // args.batch_size  <span class="comment"># 计算批次数量</span></span><br><span class="line">    indexes = np.random.shuffle(np.arange(<span class="built_in">len</span>(train_dataset))) <span class="comment"># 随机打乱数据集的索引</span></span><br><span class="line">    <span class="comment"># 初始化损失和准确率</span></span><br><span class="line">    loss_all = <span class="number">0</span></span><br><span class="line">    loss_cat_all = <span class="number">0</span></span><br><span class="line">    loss_loc_all = <span class="number">0</span></span><br><span class="line">    accuracy = <span class="number">0</span></span><br><span class="line">    num_samples = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历每个批次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_batches):</span><br><span class="line">        <span class="comment"># 初始化图像、区域、ROI索引、相对位置和类别列表</span></span><br><span class="line">        imgs = []</span><br><span class="line">        rects = []</span><br><span class="line">        roi_idxs = []</span><br><span class="line">        rela_locs = []</span><br><span class="line">        cats = []</span><br><span class="line">        <span class="comment"># 遍历每个样本</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(args.batch_size):</span><br><span class="line">            <span class="comment"># img:原始图像; rect:建议框体;roi_idx_len:正负样本框体总数;rela_loc:调整后框体;cat:类别</span></span><br><span class="line">            img, rect, roi_idx_len, rela_loc, cat = train_dataset[i *</span><br><span class="line">                                                                 args.batch_size+j]</span><br><span class="line">            <span class="comment"># print(img, rect, roi_idx_len, gt_rect, cat)</span></span><br><span class="line">            <span class="comment"># 添加到对应的列表中</span></span><br><span class="line">            imgs.append(img.unsqueeze(<span class="number">0</span>))</span><br><span class="line">            rects += rect</span><br><span class="line">            rela_locs += rela_loc</span><br><span class="line">            roi_idxs += ([j] * roi_idx_len)   <span class="comment"># [2]*6-------&gt;[2, 2, 2, 2, 2, 2]</span></span><br><span class="line">            cats += cat</span><br><span class="line">        <span class="comment"># 将列表转换为张量或数组</span></span><br><span class="line">        imgs = torch.cat(imgs, dim=<span class="number">0</span>)</span><br><span class="line">        rects = np.array(rects)</span><br><span class="line">        rela_locs = torch.FloatTensor(rela_locs)</span><br><span class="line">        cats = torch.LongTensor(cats)</span><br><span class="line">        <span class="comment"># print(imgs, rects, roi_idxs, rela_locs, cats)</span></span><br><span class="line">        <span class="comment"># 如果使用CUDA，则将张量移动到GPU上</span></span><br><span class="line">        <span class="keyword">if</span> args.cuda:</span><br><span class="line">            imgs = imgs.cuda()</span><br><span class="line">            rela_locs = rela_locs.cuda()</span><br><span class="line">            cats = cats.cuda()</span><br><span class="line">        <span class="comment"># 清空梯度</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># 前向传播，计算预测的概率和边界框</span></span><br><span class="line">        prob, bbox = model.forward(imgs, rects, roi_idxs)</span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        loss, loss_cat, loss_loc = model.loss(prob, bbox, cats, rela_locs)</span><br><span class="line">        <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># 更新损失和准确率</span></span><br><span class="line">        num_samples += <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_all += loss.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_cat_all += loss_cat.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_loc_all += loss_loc.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        accuracy += (torch.argmax(prob.detach(), dim=-<span class="number">1</span>) == cats).<span class="built_in">sum</span>().item()</span><br><span class="line">    <span class="comment"># 返回模型、损失和准确率</span></span><br><span class="line">    <span class="keyword">return</span> model, loss_all/num_samples, loss_cat_all/num_samples, loss_loc_all/num_samples, accuracy/num_samples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试函数，输入参数为模型、验证数据集和命令行参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, val_dataset, args</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    num_batches = <span class="built_in">len</span>(val_dataset) // args.batch_size <span class="comment"># 计算批次数量</span></span><br><span class="line">    indexes = np.random.shuffle(np.arange(<span class="built_in">len</span>(val_dataset))) <span class="comment"># 随机打乱数据集的索引</span></span><br><span class="line">    <span class="comment"># 初始化损失和准确率</span></span><br><span class="line">    loss_all = <span class="number">0</span></span><br><span class="line">    loss_cat_all = <span class="number">0</span></span><br><span class="line">    loss_loc_all = <span class="number">0</span></span><br><span class="line">    accuracy = <span class="number">0</span></span><br><span class="line">    num_samples = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历每个批次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_batches):</span><br><span class="line">        <span class="comment"># 初始化图像、区域、ROI索引、相对位置和类别列表</span></span><br><span class="line">        imgs = []</span><br><span class="line">        rects = []</span><br><span class="line">        roi_idxs = []</span><br><span class="line">        rela_locs = []</span><br><span class="line">        cats = []</span><br><span class="line">        <span class="comment"># 遍历每个样本</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(args.batch_size):</span><br><span class="line">            <span class="comment"># 加载图像、区域、ROI索引长度、相对位置和类别</span></span><br><span class="line">            img, rect, roi_idx_len, rela_loc, cat = val_dataset[i *</span><br><span class="line">                                                               args.batch_size+j]</span><br><span class="line">            <span class="comment"># print(img, rect, roi_idx_len, gt_rect, cat)</span></span><br><span class="line">            <span class="comment"># 添加到对应的列表中</span></span><br><span class="line">            imgs.append(img.unsqueeze(<span class="number">0</span>))</span><br><span class="line">            rects += rect</span><br><span class="line">            rela_locs += rela_loc</span><br><span class="line">            roi_idxs += ([j] * roi_idx_len)</span><br><span class="line">            cats += cat</span><br><span class="line">        <span class="comment"># 将列表转换为张量或数组</span></span><br><span class="line">        imgs = torch.cat(imgs, dim=<span class="number">0</span>)</span><br><span class="line">        rects = np.array(rects)</span><br><span class="line">        rela_locs = torch.FloatTensor(rela_locs)</span><br><span class="line">        cats = torch.LongTensor(cats)</span><br><span class="line">        <span class="comment"># print(imgs, rects, roi_idxs, rela_locs, cats)</span></span><br><span class="line">        <span class="comment"># 如果使用CUDA，则将张量移动到GPU</span></span><br><span class="line">        <span class="keyword">if</span> args.cuda:</span><br><span class="line">            imgs = imgs.cuda()</span><br><span class="line">            rela_locs = rela_locs.cuda()</span><br><span class="line">            cats = cats.cuda()</span><br><span class="line">        <span class="comment"># 前向传播，计算预测的概率和边界框</span></span><br><span class="line">        prob, bbox = model.forward(imgs, rects, roi_idxs)</span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        loss, loss_cat, loss_loc = model.loss(prob, bbox, cats, rela_locs)</span><br><span class="line">        <span class="comment"># 更新损失和准确率</span></span><br><span class="line">        num_samples += <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_all += loss.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_cat_all += loss_cat.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        loss_loc_all += loss_loc.item() * <span class="built_in">len</span>(cats)</span><br><span class="line">        accuracy += (torch.argmax(prob.detach(), dim=-<span class="number">1</span>) == cats).<span class="built_in">sum</span>().item()</span><br><span class="line">    <span class="comment"># 返回模型、损失和准确率</span></span><br><span class="line">    <span class="keyword">return</span> model, loss_all/num_samples, loss_cat_all/num_samples, loss_loc_all/num_samples, accuracy/num_samples</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&#x27;parser for fast-rcnn&#x27;</span>) <span class="comment"># 创建一个命令行参数解析器</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch_size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>) <span class="comment"># 添加一个命令行参数--batch_size，用于指定批次大小，默认值为16</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--num_classes&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>) <span class="comment"># 添加一个命令行参数--num_classes，用于指定类别数量，默认值为10</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--learning_rate&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">2e-4</span>) <span class="comment"># 添加一个命令行参数--learning_rate，用于指定学习率，默认值为2e-4</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">20</span>) <span class="comment"># 添加一个命令行参数--epochs，用于指定训练的轮数，默认值为20</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save_path&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        default=<span class="string">&#x27;./model/fast_rcnn.pkl&#x27;</span>) <span class="comment"># 添加一个命令行参数--save_path，用于指定模型保存的路径，默认值为&#x27;./model/fast_rcnn.pkl&#x27;</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cuda&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>, default=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args() <span class="comment"># 解析命令行参数，并将结果保存在args中</span></span><br><span class="line">    train_dataset = COCOdataset(mode=<span class="string">&#x27;train&#x27;</span>) <span class="comment"># 解析命令行参数，并将结果保存在args中</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>,train_dataset.__len__())</span><br><span class="line">    valid_dataset = COCOdataset(mode=<span class="string">&#x27;val&#x27;</span>) <span class="comment"># 创建一个COCOdataset实例，模式为&#x27;val&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>, valid_dataset.__len__())</span><br><span class="line">    model = FastRCNN(num_classes=args.num_classes) <span class="comment"># 创建一个FastRCNN模型实例，类别数量为args.num_classes</span></span><br><span class="line">    <span class="keyword">if</span> args.cuda:<span class="comment"># 如果args.cuda为True，则将模型移动到GPU上</span></span><br><span class="line">        model.cuda()</span><br><span class="line">    optimizer = optim.Adam(model.parameters(), lr=args.learning_rate) <span class="comment"># 创建一个Adam优化器，优化目标为模型的参数，学习率为args.learning_rate</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(args.epochs):<span class="comment"># 对于每一个训练轮次</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Epoch %d:&quot;</span> % epoch)<span class="comment"># 打印当前轮次</span></span><br><span class="line">        model, train_loss, train_loss_cat, train_loss_loc, train_accuracy = train(</span><br><span class="line">            model, train_dataset, optimizer, args) <span class="comment"># 调用train函数进行训练，并获取模型、总损失、类别损失、位置损失和准确率</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Train: loss=%.4f, loss_cat=%.4f, loss_loc=%.4f, accuracy=%.4f&quot;</span> %</span><br><span class="line">              (train_loss, train_loss_cat, train_loss_loc, train_accuracy))<span class="comment"># 打印训练的损失和准确率</span></span><br><span class="line">        model, valid_loss, valid_loss_cat, valid_loss_loc, valid_accuracy = test(</span><br><span class="line">            model, valid_dataset, args)<span class="comment"># 打印训练的损失和准确率</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Valid: loss=%.4f, loss_cat=%.4f, loss_loc=%.4f, accuracy=%.4f&quot;</span> %</span><br><span class="line">              (valid_loss, valid_loss_cat, valid_loss_loc, valid_accuracy))<span class="comment"># 打印验证的损失和准确率</span></span><br><span class="line"></span><br><span class="line">    torch.save(model.state_dict(), args.save_path) <span class="comment"># 将模型的状态字典保存到args.save_path指定的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main() <span class="comment"># 如果当前脚本被直接运行，则调用main函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试">测试</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> skimage</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> selectivesearch <span class="keyword">import</span> selective_search <span class="comment"># 从selectivesearch模块导入selective_search函数，用于进行选择性搜索</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fast_rcnn <span class="keyword">import</span> FastRCNN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试时如果用gpu，则：</span></span><br><span class="line"><span class="comment"># 1. 将模型加载到gpu上：trained_net = torch.load(args.model)，不加 map_location = &#x27;cpu&#x27;</span></span><br><span class="line"><span class="comment"># 2. 把参数--cuda的默认值改为True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义计算IoU（交并比）的函数，输入参数为两个矩形框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_iou</span>(<span class="params">a, b</span>):</span><br><span class="line">    a_min_x, a_min_y, a_max_x, a_max_y = a</span><br><span class="line">    b_min_x, b_min_y, b_max_x, b_max_y = b</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span>(a_max_y, b_max_y) &lt; <span class="built_in">max</span>(a_min_y, b_min_y) <span class="keyword">or</span> <span class="built_in">min</span>(a_max_x, b_max_x) &lt; <span class="built_in">max</span>(a_min_x, b_min_x):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        intersect_area = (<span class="built_in">min</span>(a_max_y, b_max_y) - <span class="built_in">max</span>(a_min_y, b_min_y) + <span class="number">1</span>) * \</span><br><span class="line">            (<span class="built_in">min</span>(a_max_x, b_max_x) - <span class="built_in">max</span>(a_min_x, b_min_x) + <span class="number">1</span>)</span><br><span class="line">        union_area = (a_max_x - a_min_x + <span class="number">1</span>) * (a_max_y - a_min_y + <span class="number">1</span>) + \</span><br><span class="line">            (b_max_x - b_min_x + <span class="number">1</span>) * (b_max_y - b_min_y + <span class="number">1</span>) - intersect_area</span><br><span class="line">    <span class="keyword">return</span> intersect_area / union_area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&#x27;parser for testing fast-rcnn&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--jpg_path&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        default=<span class="string">&#x27;D:\\WritePapers\\object_detection_basics\\Datasets\\COCO2017\\val2017\\000000241326.jpg&#x27;</span>)<span class="comment"># 添加一个命令行参数--jpg_path，用于指定待测试的图像的路径，默认值为&#x27;/devdata/project/ai_learn/COCO2017/val2017/000000241326.jpg&#x27;</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save_path&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;sample.png&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--save_type&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--model&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;./model/fast_rcnn.pkl&#x27;</span>) <span class="comment"># 添加一个命令行参数--model，用于指定模型的路径，默认值为&#x27;./model/fast_rcnn.pkl&#x27;</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--num_classes&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--scale&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">30.0</span>) <span class="comment"># 添加一个命令行参数--scale，用于指定选择性搜索的尺度，默认值为30.0</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--sigma&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.8</span>) <span class="comment"># 添加一个命令行参数--sigma，用于指定选择性搜索的高斯平滑参数，默认值为0.8</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--min_size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">50</span>) <span class="comment"># 添加一个命令行参数--min_size，用于指定选择性搜索的最小区域大小，默认值为50</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cats&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, nargs=<span class="string">&#x27;*&#x27;</span>, default=[</span><br><span class="line">                        <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>]) <span class="comment"># 添加一个命令行参数--cats，用于指定需要处理的类别，默认值为一系列动物的名称</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cuda&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>, default=<span class="literal">False</span>)</span><br><span class="line">    args = parser.parse_args() <span class="comment"># 解析命令行参数，并将结果保存在args中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trained_net = torch.load(args.model) # 加载模型</span></span><br><span class="line">    trained_net = torch.load(args.model, map_location = <span class="string">&#x27;cpu&#x27;</span>) <span class="comment"># 加载模型</span></span><br><span class="line"></span><br><span class="line">    model = FastRCNN(num_classes=args.num_classes) <span class="comment"># 创建一个FastRCNN模型实例，类别数量为args.num_classes</span></span><br><span class="line">    model.load_state_dict(trained_net) <span class="comment"># 将加载的模型的状态字典加载到FastRCNN模型实例中</span></span><br><span class="line">    <span class="keyword">if</span> args.cuda: <span class="comment"># 如果args.cuda为True，则将模型移动到GPU上</span></span><br><span class="line">        model.cuda()</span><br><span class="line"></span><br><span class="line">    img = skimage.io.imread(args.jpg_path) <span class="comment"># 读取图像</span></span><br><span class="line">    h = img.shape[<span class="number">0</span>] <span class="comment"># 获取图像的高度</span></span><br><span class="line">    w = img.shape[<span class="number">1</span>] <span class="comment"># 获取图像的宽度</span></span><br><span class="line">    _, ss_regions = selective_search(</span><br><span class="line">        img, args.scale, args.sigma, args.min_size) <span class="comment"># 对图像进行选择性搜索，获取候选区域</span></span><br><span class="line">    rois = []</span><br><span class="line">    <span class="keyword">for</span> region <span class="keyword">in</span> ss_regions: <span class="comment"># 遍历每个候选区域</span></span><br><span class="line">        rect = <span class="built_in">list</span>(region[<span class="string">&#x27;rect&#x27;</span>]) <span class="comment"># 获取候选区域的矩形框</span></span><br><span class="line">        rect[<span class="number">0</span>] = rect[<span class="number">0</span>] / w <span class="comment"># 将矩形框的x坐标转换为相对于图像宽度的比例</span></span><br><span class="line">        rect[<span class="number">1</span>] = rect[<span class="number">1</span>] / h <span class="comment"># 将矩形框的y坐标转换为相对于图像高度的比例</span></span><br><span class="line">        rect[<span class="number">2</span>] = rect[<span class="number">0</span>] + rect[<span class="number">2</span>] / w <span class="comment"># 将矩形框的宽度转换为相对于图像宽度的比例</span></span><br><span class="line">        rect[<span class="number">3</span>] = rect[<span class="number">1</span>] + rect[<span class="number">3</span>] / h <span class="comment"># 将矩形框的高度转换为相对于图像高度的比例</span></span><br><span class="line">        rois.append(rect) <span class="comment"># 将处理后的矩形框添加到列表中</span></span><br><span class="line">    img = Image.fromarray(img) <span class="comment"># 将图像数组转换为PIL图像</span></span><br><span class="line">    img_tensor = img.resize([<span class="number">224</span>, <span class="number">224</span>]) <span class="comment"># 将图像大小调整为224x224</span></span><br><span class="line">    transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize([</span><br><span class="line">                                   <span class="number">0.485</span>, <span class="number">0.456</span>, -<span class="number">.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])]) <span class="comment"># 创建一个图像预处理管道，包括将PIL图像转换为张量和标准化</span></span><br><span class="line">    img_tensor = transform(img_tensor).unsqueeze(<span class="number">0</span>) <span class="comment"># 对图像进行预处理，并添加一个新的维度</span></span><br><span class="line">    <span class="keyword">if</span> args.cuda: <span class="comment"># 如果args.cuda为True，则将图像张量移动到GPU</span></span><br><span class="line">        img_tensor = img_tensor.cuda()</span><br><span class="line">    rois = np.array(rois) <span class="comment"># 将候选区域的列表转换为数组</span></span><br><span class="line">    roi_idx = [<span class="number">0</span>] * rois.shape[<span class="number">0</span>] <span class="comment"># 创建一个列表，长度为候选区域的数量，所有元素都为0</span></span><br><span class="line"></span><br><span class="line">    prob, rela_loc = model.forward(img_tensor, rois, roi_idx) <span class="comment"># 前向传播，计算预测的概率和边界框</span></span><br><span class="line">    prob = torch.nn.Softmax(dim=-<span class="number">1</span>)(prob).cpu().detach().numpy() <span class="comment"># 对预测的概率进行softmax操作，并将结果转换为numpy数组</span></span><br><span class="line">    <span class="comment"># rela_loc = rela_loc.cpu().detach().numpy()[:, 1:, :].mean(axis=1)</span></span><br><span class="line">    labels = []</span><br><span class="line">    max_probs = []</span><br><span class="line">    bboxs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prob)): <span class="comment"># 遍历每个预测的概率</span></span><br><span class="line">        <span class="keyword">if</span> prob[i].<span class="built_in">max</span>() &gt; <span class="number">0.8</span> <span class="keyword">and</span> np.argmax(prob[i], axis=<span class="number">0</span>) != <span class="number">0</span>: <span class="comment"># 如果最大概率大于0.8且对应的类别不是背景，则认为候选区域是有效的</span></span><br><span class="line">            <span class="comment"># proposal regions is directly used because of limited training epochs, bboxs predicted are not precise</span></span><br><span class="line">            <span class="comment"># bbox = [(rois[i][2] - rois[i][0]) * rela_loc[i][0] + 0.5 * (rois[i][2] + rois[i][0]),</span></span><br><span class="line">            <span class="comment">#         (rois[i][3] - rois[i][1]) * rela_loc[i][1] + 0.5 * (rois[i][3] + rois[i][1]),</span></span><br><span class="line">            <span class="comment">#         np.exp(rela_loc[i][2]) * rois[i][2],</span></span><br><span class="line">            <span class="comment">#         np.exp(rela_loc[i][3]) * rois[i][3]]</span></span><br><span class="line">            <span class="comment"># bbox = [bbox[0] - 0.5 * bbox[2],</span></span><br><span class="line">            <span class="comment">#         bbox[1] - 0.5 * bbox[3],</span></span><br><span class="line">            <span class="comment">#         bbox[0] + 0.5 * bbox[2],</span></span><br><span class="line">            <span class="comment">#         bbox[1] + 0.5 * bbox[3]]</span></span><br><span class="line">            labels.append(np.argmax(prob[i], axis=<span class="number">0</span>))  <span class="comment"># 将有效候选区域的类别添加到列表中</span></span><br><span class="line">            max_probs.append(prob[i].<span class="built_in">max</span>()) <span class="comment"># 将有效候选区域的最大概率添加到列表中</span></span><br><span class="line">            rois[i] = [<span class="built_in">int</span>(w * rois[i][<span class="number">0</span>]), <span class="built_in">int</span>(h * rois[i][<span class="number">1</span>]),</span><br><span class="line">                       <span class="built_in">int</span>(w * rois[i][<span class="number">2</span>]), <span class="built_in">int</span>(w * rois[i][<span class="number">3</span>])] <span class="comment"># 将候选区域的矩形框的坐标和大小转换为相对于原图的像素值</span></span><br><span class="line">            bboxs.append(rois[i]) <span class="comment"># 将处理后的矩形框添加到列表中</span></span><br><span class="line">    labels = np.array(labels) <span class="comment"># 将类别的列表转换为数组</span></span><br><span class="line">    max_probs = np.array(max_probs) <span class="comment"># 将最大概率的列表转换为数组</span></span><br><span class="line">    bboxs = np.array(bboxs) <span class="comment"># 将矩形框的列表转换为数组</span></span><br><span class="line">    order = np.argsort(-max_probs) <span class="comment"># 对最大概率进行降序排序，获取排序后的索引</span></span><br><span class="line">    labels = labels[order] <span class="comment"># 根据排序的索引重新排序类别</span></span><br><span class="line">    max_probs = max_probs[order]</span><br><span class="line">    bboxs = bboxs[order]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面的代码是进行非极大值抑制（NMS），用于去除重叠的候选区域</span></span><br><span class="line">    nms_labels = []</span><br><span class="line">    nms_probs = []</span><br><span class="line">    nms_bboxs = []</span><br><span class="line">    del_indexes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> del_indexes:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> del_indexes <span class="keyword">and</span> cal_iou(bboxs[i], bboxs[j]) &gt; <span class="number">0.3</span>:</span><br><span class="line">                    del_indexes.append(j)</span><br><span class="line">            nms_labels.append(labels[i])</span><br><span class="line">            nms_probs.append(max_probs[i])</span><br><span class="line">            nms_bboxs.append(bboxs[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将预测结果绘制到图像上</span></span><br><span class="line">    cat_dict = &#123;(i + <span class="number">1</span>): args.cats[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(args.cats))&#125;</span><br><span class="line">    cat_dict[<span class="number">0</span>] = <span class="string">&#x27;background&#x27;</span></span><br><span class="line">    font = ImageFont.truetype(<span class="string">&#x27;./fonts/chinese_cht.ttf&#x27;</span>, size=<span class="number">16</span>)</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nms_labels)):</span><br><span class="line">        draw.polygon([(nms_bboxs[i][<span class="number">0</span>], nms_bboxs[i][<span class="number">1</span>]), (nms_bboxs[i][<span class="number">2</span>], nms_bboxs[i][<span class="number">1</span>]),</span><br><span class="line">                      (nms_bboxs[i][<span class="number">2</span>], nms_bboxs[i][<span class="number">3</span>]), (nms_bboxs[i][<span class="number">0</span>], nms_bboxs[i][<span class="number">3</span>])], outline=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        draw.text((nms_bboxs[i][<span class="number">0</span>] + <span class="number">5</span>, nms_bboxs[i][<span class="number">1</span>] + <span class="number">5</span>), <span class="string">&#x27;%s %.2f%%&#x27;</span> % (</span><br><span class="line">            cat_dict[nms_labels[i]], <span class="number">100</span> * max_probs[i]), fill=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), font=font)</span><br><span class="line">    img.save(args.save_path, args.save_type) <span class="comment"># 将绘制了预测结果的图像保存到指定的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果如下： <img src="https://ooo.0x0.ooo/2023/12/29/OKYvBc.png"
alt="OKYvBc.png" /></p>
<p>参考资料</p>
<blockquote>
<p>1.博客：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/guoqingru0311/article/details/129584426">目标检测
pytorch复现Fast_RCNN目标检测项目-CSDN博客</a></p>
<p>2.COCO数据集下载：</p>
<p>``` 训练集： http://images.cocodataset.org/zips/train2017.zip
验证集： http://images.cocodataset.org/zips/val2017.zip
训练集和验证集对应的标签：
http://images.cocodataset.org/annotations/annotations_trainval2017.zip
测试集： http://images.cocodataset.org/zips/test2017.zip</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Fast-RCNN/" rel="tag"># Fast RCNN</a>
              <a href="/tags/%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/" rel="tag"># 代码复现</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/29/Fast-RCNN%E8%AE%BA%E6%96%87%E7%90%86%E8%A7%A3/" rel="prev" title="Fast RCNN论文理解">
                  <i class="fa fa-angle-left"></i> Fast RCNN论文理解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/29/Faster-RCNN%E8%AE%BA%E6%96%87%E7%90%86%E8%A7%A3/" rel="next" title="Faster RCNN论文理解">
                  Faster RCNN论文理解 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
<!--
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">deeprookie</span>
  </div>
-->

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
